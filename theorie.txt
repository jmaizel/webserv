definition socket : 

les sockets sont la base de la communication reseau. c est comme une prise ou un point de connexion pour communiquer sur le reseau.
on l utilise comme points de passage pour faire passer des donnees.

--> annalogie simple, un socket c est comme une boite au letre, on peut envoyer des lettres ou en recevoir.

dans notre cas a nous on va utiliser des socket TCP qui vont connecter le client et le serveur. voici les avamtages :

- connexion fiable : si tu envoie "ABC" ca arrive "ABC"
- ordre garante : les donnees arrivent dans l ordre
- detection d erreurs : si ca se perd on le sait
- comme un appel telephonique : connexion etable, conversation , raccrochage 


SERVEUR                           CLIENT
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Socket      â”‚                  â”‚ Socket      â”‚
â”‚ (Ã©coute)    â”‚                  â”‚             â”‚
â”‚ 127.0.0.1   â”‚ â†â”€â”€ connect â”€â”€â”€â”€ â”‚ random_port â”‚
â”‚ :8080       â”‚                  â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ accept() crÃ©e un nouveau socket
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Socket      â”‚ â†â”€â”€ recv/send â”€â”€â†’ Client
â”‚ (client)    â”‚
â”‚ fd = 5      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Alice                    Bob
â”Œâ”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”
â”‚     â”‚ â†â”€â”€ LIGNE â”€â”€â”€â†’ â”‚     â”‚
â””â”€â”€â”€â”€â”€â”˜    (socket)    â””â”€â”€â”€â”€â”€â”˜
  â†‘                      â†‘
"Salut Bob!"         "Salut Alice!"
(les donnÃ©es)        (les donnÃ©es)


==> ligne pour creer le socket :

 _server_fd = socket(AF_INET, SOCK_STREAM, 0);
 AF_INET = IPV4
 SOCK_STREAM = TCP (connexion fiable)







ce qu il va se passe , a la creation de l objet server , on vide completement les fd_set mais on a aucun socket , les fd_set sont prets mais vides. et quand
on lance le serveur : 
server.ft_init_server();      // ICI on crÃ©e le socket
server.ft_start_listening();  // ICI on ajoute le socket aux fd_set


on doit initialise les fd_set dans le constructer car les fd_set contiennent des bits aleatoires en memoire au debut , donc si on ne les initialise pas a 0 on 
peut avoir des problemes.



explication des methodes : 

LA METHODE GET : 

get est la methode HTTP la plus simple, elle dit "donne moi la ressource qui se trouve a cette adresse". GET est donc un protoal HTTP pour demander une ressource.

- exemple d une requete GET :

GET /about.html HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0...
Accept: text/html,application/xhtml+xml...
Connection: keep-alive

[corps vide - GET n'a jamais de body]

- exemple d une reponse GET :

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 226
Date: Thu, 12 Jun 2025 14:30:00 GMT

<!DOCTYPE html>
<html>
<head>...
[contenu du fichier]

--> les 3 technologies fondamentales que le navigateur web peut interpreter nativement : du hTML ( role structure et contenu de la page)
du CSS (Apparence et mise en page), JAVASCRIPT (interactivite et logique)

Dans webServ, on fait une requete script, Webserv execute python et c est python qui genere/formate le HTML



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            ğŸš€ DÃ‰MARRAGE DU SERVEUR                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£ main.cpp lance le serveur
   â”œâ”€â”€ VÃ©rifie les arguments (config.conf)
   â”œâ”€â”€ parseConfigFile() â†’ Parse le fichier de configuration
   â”‚   â”œâ”€â”€ Lit server { listen, server_name, root, index, allowed_methods }
   â”‚   â””â”€â”€ Lit location { path, root, index, allowed_methods, client_max_body_size }
   â”œâ”€â”€ ft_print_config() â†’ Affiche la configuration parsÃ©e de maniÃ¨re claire
   â””â”€â”€ CrÃ©e Server(config) avec la configuration complÃ¨te

2ï¸âƒ£ Server::ft_init_server()
   â”œâ”€â”€ socket() â†’ CrÃ©e le socket TCP
   â”œâ”€â”€ setsockopt(SO_REUSEADDR) â†’ Permet de redÃ©marrer rapidement
   â”œâ”€â”€ fcntl(O_NONBLOCK) â†’ Socket non-bloquant
   â”œâ”€â”€ bind() â†’ Lie le socket au port (_config.listen)
   â””â”€â”€ Configuration depuis _config au lieu de valeurs en dur

3ï¸âƒ£ Server::ft_start_listening()
   â”œâ”€â”€ listen() â†’ Met le socket en Ã©coute
   â”œâ”€â”€ FD_SET() â†’ Ajoute le socket au fd_set
   â””â”€â”€ Affiche "Server listening on {server_name}:{port}"

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ğŸ”„ BOUCLE PRINCIPALE DU SERVEUR                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4ï¸âƒ£ Server::ft_handle_connections() - BOUCLE INFINIE
   â”œâ”€â”€ select() â†’ Attend des Ã©vÃ©nements sur les sockets
   â”œâ”€â”€ Parcourt tous les file descriptors
   â””â”€â”€ Pour chaque socket actif :
       â”œâ”€â”€ Si c'est _server_fd â†’ ft_accept_new_client()
       â””â”€â”€ Sinon â†’ ft_handle_client_request(client_fd)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ğŸ¤ GESTION D'UNE NOUVELLE CONNEXION                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5ï¸âƒ£ Server::ft_accept_new_client()
   â”œâ”€â”€ accept() â†’ Accepte la connexion client
   â”œâ”€â”€ fcntl(O_NONBLOCK) â†’ Rend le socket client non-bloquant
   â”œâ”€â”€ FD_SET() â†’ Ajoute le client au fd_set de surveillance
   â”œâ”€â”€ _client_fds.push_back() â†’ Stocke le fd client
   â””â”€â”€ Met Ã  jour _max_fd si nÃ©cessaire

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ğŸ“¨ TRAITEMENT D'UNE REQUÃŠTE CLIENT                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

6ï¸âƒ£ Server::ft_handle_client_request(client_fd)
   â”‚
   â”œâ”€â”€ recv() â†’ ReÃ§oit les donnÃ©es brutes du client
   â”‚   â””â”€â”€ Exemple : "GET /hello.py?name=test HTTP/1.1\r\nHost: localhost..."
   â”‚
   â”œâ”€â”€ ft_is_request_complete() â†’ VÃ©rifie si la requÃªte est complÃ¨te
   â”‚   â”œâ”€â”€ Cherche "\r\n\r\n" (fin des headers)
   â”‚   â”œâ”€â”€ Pour GET/DELETE : OK si headers complets
   â”‚   â””â”€â”€ Pour POST : VÃ©rifie que le body est complet selon Content-Length
   â”‚
   â”œâ”€â”€ ft_parse_http_request() â†’ PARSING COMPLET DE LA REQUÃŠTE
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ğŸ“ ft_parse_request_line() **â­ MODIFIÃ‰ !**
   â”‚   â”‚   â”œâ”€â”€ SÃ©pare "GET /hello.py?name=test HTTP/1.1"
   â”‚   â”‚   â”œâ”€â”€ Valide method âˆˆ {GET, POST, DELETE}
   â”‚   â”‚   â”œâ”€â”€ Valide version = "HTTP/1.1"
   â”‚   â”‚   â”œâ”€â”€ **NOUVEAU** : SÃ©pare URI et query string
   â”‚   â”‚   â”‚   â”œâ”€â”€ Si '?' trouvÃ© â†’ uri="/hello.py", query_string="name=test"
   â”‚   â”‚   â”‚   â””â”€â”€ Sinon â†’ uri="/hello.py", query_string=""
   â”‚   â”‚   â””â”€â”€ Stocke : request.method, request.uri, request.query_string, request.version
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ğŸ“‹ ft_parse_headers()
   â”‚   â”‚   â”œâ”€â”€ Parse chaque ligne "Key: Value"
   â”‚   â”‚   â”œâ”€â”€ Trim les espaces
   â”‚   â”‚   â”œâ”€â”€ Convertit les clÃ©s en minuscules
   â”‚   â”‚   â””â”€â”€ Stocke dans request.headers["key"] = "value"
   â”‚   â”‚
   â”‚   â””â”€â”€ Pour POST : Extrait le body selon Content-Length
   â”‚       â””â”€â”€ Stocke dans request.body
   â”‚
   â””â”€â”€ ft_handle_request_with_config(method, uri, body) â†’ TRAITEMENT AVEC CONFIG

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    âš™ï¸ TRAITEMENT AVEC CONFIGURATION                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

7ï¸âƒ£ Server::ft_handle_request_with_config(method, uri, body)
   â”‚
   â”œâ”€â”€ ğŸ¯ ft_find_location(uri) â†’ Trouve la location qui match
   â”‚   â”œâ”€â”€ Parcourt _config.locations[]
   â”‚   â”œâ”€â”€ VÃ©rifie si uri.find(location.path) == 0
   â”‚   â””â”€â”€ Prend la location avec le path le plus long (plus prÃ©cise)
   â”‚   
   â”œâ”€â”€ âœ… ft_is_method_allowed(method, location)
   â”‚   â”œâ”€â”€ Utilise location->allowed_methods si existe
   â”‚   â”œâ”€â”€ Sinon utilise _config.allowed_methods
   â”‚   â””â”€â”€ Retourne true/false selon si method est autorisÃ©e
   â”‚
   â””â”€â”€ Router selon la mÃ©thode :
       â”œâ”€â”€ GET â†’ ft_serve_static_file_with_config(uri)
       â”œâ”€â”€ POST â†’ ft_handle_post_request_with_config(uri, body)
       â””â”€â”€ DELETE â†’ ft_handle_delete(uri)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ğŸ“ SERVIR UN FICHIER STATIQUE                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

8ï¸âƒ£ Server::ft_serve_static_file_with_config(uri) **â­ MODIFIÃ‰ !**
   â”‚
   â”œâ”€â”€ ğŸ¯ ft_find_location(uri) â†’ Re-trouve la location
   â”‚
   â”œâ”€â”€ ğŸ“‚ ft_get_file_path(uri, location) â†’ CONSTRUCTION DU CHEMIN
   â”‚   â”‚
   â”‚   â”œâ”€â”€ DÃ©termine root et index :
   â”‚   â”‚   â”œâ”€â”€ Si location existe : location->root ou _config.root
   â”‚   â”‚   â””â”€â”€ Sinon : _config.root et _config.index
   â”‚   â”‚
   â”‚   â”œâ”€â”€ Construction du chemin :
   â”‚   â”‚   â”œâ”€â”€ Si uri == "/" â†’ root + "/" + index
   â”‚   â”‚   â”œâ”€â”€ Si fichier avec extension â†’ root + uri
   â”‚   â”‚   â”œâ”€â”€ Si location et uri match location->path â†’ 
   â”‚   â”‚   â”‚   â””â”€â”€ EnlÃ¨ve le path de location de l'URI
   â”‚   â”‚   â””â”€â”€ Sinon â†’ root + uri
   â”‚   â”‚
   â”‚   â””â”€â”€ Exemples :
   â”‚       â”œâ”€â”€ uri="/" â†’ "./www/index.html"
   â”‚       â”œâ”€â”€ uri="/hello.py" â†’ "./www/hello.py"
   â”‚       â””â”€â”€ uri="/cgi-bin/script.py" â†’ "./www/cgi-bin/script.py"
   â”‚
   â”œâ”€â”€ ğŸ **NOUVEAU** : DÃ©tection CGI amÃ©liorÃ©e
   â”‚   â”‚   Si file_path se termine par ".py" :
   â”‚   â”‚   â”œâ”€â”€ CrÃ©e un HttpRequest basique pour CGI
   â”‚   â”‚   â”œâ”€â”€ cgi_request.method = "GET"
   â”‚   â”‚   â”œâ”€â”€ cgi_request.uri = uri (sans query string)
   â”‚   â”‚   â”œâ”€â”€ **Extrait la query string de l'URI original**
   â”‚   â”‚   â”‚   â”œâ”€â”€ Si uri contient '?' â†’ sÃ©pare URI et query
   â”‚   â”‚   â”‚   â””â”€â”€ cgi_request.query_string = "name=test"
   â”‚   â”‚   â””â”€â”€ ft_execute_cgi(file_path, cgi_request) **avec HttpRequest**
   â”‚
   â”œâ”€â”€ ğŸ“– ft_read_file_simple(file_path) â†’ Lit le fichier
   â”‚   â”œâ”€â”€ ifstream(file_path) â†’ Ouvre le fichier
   â”‚   â”œâ”€â”€ getline() en boucle â†’ Lit ligne par ligne
   â”‚   â””â”€â”€ Retourne le contenu ou "" si erreur
   â”‚
   â”œâ”€â”€ ğŸ·ï¸ ft_get_content_type(file_path) â†’ DÃ©termine le MIME type
   â”‚   â”œâ”€â”€ Trouve l'extension (.html, .css, .js, .png...)
   â”‚   â””â”€â”€ Retourne le Content-Type appropriÃ©
   â”‚
   â””â”€â”€ ğŸ“¤ Construction de la rÃ©ponse HTTP :
       â”œâ”€â”€ "HTTP/1.1 200 OK\r\n"
       â”œâ”€â”€ "Content-Type: text/html\r\n"
       â”œâ”€â”€ "Content-Length: 1234\r\n"
       â”œâ”€â”€ "Server: WebServ/1.0\r\n"
       â”œâ”€â”€ "Connection: close\r\n"
       â”œâ”€â”€ "\r\n"
       â””â”€â”€ [contenu du fichier]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ğŸ EXÃ‰CUTION CGI COMPLÃˆTE **â­ NOUVEAU !**            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

9ï¸âƒ£ Server::ft_execute_cgi(script_path, HttpRequest& request) **VERSION AVANCÃ‰E**
   â”‚
   â”œâ”€â”€ ğŸ”§ CrÃ©ation des pipes
   â”‚   â”œâ”€â”€ pipe(pipe_in) â†’ Communication serveur â†’ script (stdin)
   â”‚   â””â”€â”€ pipe(pipe_out) â†’ Communication script â†’ serveur (stdout)
   â”‚
   â”œâ”€â”€ ğŸ´ fork() â†’ CrÃ©e un processus enfant dÃ©diÃ© au script
   â”‚
   â”œâ”€â”€ ğŸ‘¶ **PROCESSUS ENFANT** (le script Python) :
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ğŸ”€ Redirection des flux
   â”‚   â”‚   â”œâ”€â”€ dup2(pipe_in[0], STDIN_FILENO) â†’ stdin = pipe du parent
   â”‚   â”‚   â””â”€â”€ dup2(pipe_out[1], STDOUT_FILENO) â†’ stdout = pipe vers parent
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ğŸŒ **Variables d'environnement CGI** (standard complet) :
   â”‚   â”‚   â”œâ”€â”€ setenv("REQUEST_METHOD", "GET", 1)
   â”‚   â”‚   â”œâ”€â”€ setenv("QUERY_STRING", "name=test", 1) **â­ CORRIGÃ‰ !**
   â”‚   â”‚   â”œâ”€â”€ setenv("SERVER_NAME", "localhost", 1)
   â”‚   â”‚   â”œâ”€â”€ setenv("SERVER_PORT", "8080", 1)
   â”‚   â”‚   â”œâ”€â”€ setenv("SCRIPT_NAME", "./www/hello.py", 1)
   â”‚   â”‚   â”œâ”€â”€ setenv("SERVER_PROTOCOL", "HTTP/1.1", 1)
   â”‚   â”‚   â”œâ”€â”€ setenv("GATEWAY_INTERFACE", "CGI/1.1", 1)
   â”‚   â”‚   â””â”€â”€ Pour POST : setenv("CONTENT_LENGTH", body_size, 1)
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ğŸ“‚ **Gestion des chemins corrigÃ©e** :
   â”‚   â”‚   â”œâ”€â”€ chdir("./www") â†’ Change vers le rÃ©pertoire www
   â”‚   â”‚   â”œâ”€â”€ Si script_path = "./www/hello.py" â†’ script_name = "hello.py"
   â”‚   â”‚   â””â”€â”€ Ã‰vite le double "./www/./www/" dans les chemins
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ğŸš€ execve("/usr/bin/python3", ["python3", "hello.py"], environ)
   â”‚   â””â”€â”€ Si execve Ã©choue â†’ exit(1)
   â”‚
   â””â”€â”€ ğŸ‘¨â€ğŸ’» **PROCESSUS PARENT** (ton serveur) :
       â”‚
       â”œâ”€â”€ ğŸ“¤ Si POST : write(pipe_in[1], request.body) â†’ Envoie donnÃ©es au script
       â”œâ”€â”€ ğŸ“– read(pipe_out[0], buffer) â†’ Lit la sortie du script en boucle
       â”œâ”€â”€ â³ waitpid(pid, &status, 0) â†’ Attend que le script se termine
       â”œâ”€â”€ âœ… VÃ©rifie WEXITSTATUS(status) == 0 â†’ Script terminÃ© correctement
       â””â”€â”€ ft_build_cgi_response(cgi_output) â†’ Construit la rÃ©ponse HTTP

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ğŸ CE QUI SE PASSE DANS LE SCRIPT PYTHON                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”Ÿ Dans hello.py (processus enfant sÃ©parÃ©) :
   â”‚
   â”œâ”€â”€ ğŸ“– Le script lit les variables d'environnement :
   â”‚   â”œâ”€â”€ os.environ.get('REQUEST_METHOD') â†’ "GET"
   â”‚   â”œâ”€â”€ os.environ.get('QUERY_STRING') â†’ "name=test" **â­ MAINTENANT Ã‡A MARCHE !**
   â”‚   â”œâ”€â”€ os.environ.get('SERVER_NAME') â†’ "localhost"
   â”‚   â””â”€â”€ Si POST : sys.stdin.read(content_length) â†’ Lit le body
   â”‚
   â”œâ”€â”€ ğŸ“ Le script gÃ©nÃ¨re sa rÃ©ponse :
   â”‚   â”œâ”€â”€ print("Content-Type: text/html") â†’ Header CGI
   â”‚   â”œâ”€â”€ print("") â†’ Ligne vide obligatoire
   â”‚   â””â”€â”€ print("<html>...") â†’ Body HTML
   â”‚
   â””â”€â”€ ğŸ“¤ Sortie du script (via stdout = pipe vers parent) :
       â””â”€â”€ "Content-Type: text/html\n\n<html><body>...</body></html>"

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ğŸ“¤ CONSTRUCTION DE LA RÃ‰PONSE HTTP                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£1ï¸âƒ£ Server::ft_build_cgi_response(cgi_output) **â­ MODIFIÃ‰ !**
   â”‚
   â”œâ”€â”€ ğŸ” Cherche le sÃ©parateur headers/body dans la sortie CGI
   â”‚   â”œâ”€â”€ Cherche "\n\n" ou "\r\n\r\n"
   â”‚   â”œâ”€â”€ cgi_headers = "Content-Type: text/html"
   â”‚   â””â”€â”€ cgi_body = "<html><body>...</body></html>"
   â”‚
   â”œâ”€â”€ ğŸ”§ Normalise les headers CGI (convertit \n en \r\n)
   â”‚
   â””â”€â”€ ğŸ“¦ Construit la rÃ©ponse HTTP complÃ¨te :
       â”œâ”€â”€ "HTTP/1.1 200 OK\r\n"
       â”œâ”€â”€ "Content-Type: text/html\r\n" (du script)
       â”œâ”€â”€ "Content-Length: 156\r\n" (calculÃ© automatiquement)
       â”œâ”€â”€ "Server: WebServ/1.0\r\n"
       â”œâ”€â”€ "Connection: close\r\n"
       â”œâ”€â”€ "\r\n"
       â””â”€â”€ "<html><body>...</body></html>" (du script)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ğŸ“¤ ENVOI DE LA RÃ‰PONSE                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ï¸âƒ£2ï¸âƒ£ Retour dans ft_handle_client_request()
   â”œâ”€â”€ send(client_fd, response) â†’ Envoie la rÃ©ponse HTTP au client
   â””â”€â”€ ft_disconnect_client() â†’ Ferme la connexion
       â”œâ”€â”€ close(client_fd) â†’ Ferme le socket
       â”œâ”€â”€ FD_CLR() â†’ Retire de la surveillance
       â””â”€â”€ Supprime de _client_fds

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                             ğŸ”„ RETOUR EN BOUCLE                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Le serveur retourne en boucle Ã  l'Ã©tape 4ï¸âƒ£ et attend la prochaine connexion...

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ğŸ“Š EXEMPLE COMPLET : curl "/hello.py?name=test"          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. **curl envoie** : "GET /hello.py?name=test HTTP/1.1\r\nHost: localhost:8080\r\n\r\n"

2. **ft_parse_request_line()** sÃ©pare :
   â”œâ”€â”€ method = "GET"
   â”œâ”€â”€ uri = "/hello.py" (sans query string !)
   â”œâ”€â”€ query_string = "name=test" 
   â””â”€â”€ version = "HTTP/1.1"

3. **ft_serve_static_file_with_config()** :
   â”œâ”€â”€ file_path = "./www/hello.py"
   â”œâ”€â”€ DÃ©tecte ".py" â†’ CGI !
   â”œâ”€â”€ CrÃ©e HttpRequest avec query_string = "name=test"
   â””â”€â”€ ft_execute_cgi("./www/hello.py", request)

4. **CGI fork()** :
   â”œâ”€â”€ **Enfant** : 
   â”‚   â”œâ”€â”€ chdir("./www")
   â”‚   â”œâ”€â”€ setenv("QUERY_STRING", "name=test", 1)
   â”‚   â””â”€â”€ execve("python3", ["hello.py"])
   â””â”€â”€ **Parent** : attend et lit la sortie

5. **hello.py** lit os.environ['QUERY_STRING'] = "name=test" âœ…

6. **Script gÃ©nÃ¨re** : "Content-Type: text/html\n\n<h1>Hello!</h1><p>Query: name=test</p>"

7. **ft_build_cgi_response()** construit la rÃ©ponse HTTP complÃ¨te

8. **send()** envoie au client qui reÃ§oit le HTML avec "Query: name=test" âœ…

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          ğŸ¯ DIFFÃ‰RENCES PRINCIPALES                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

**AVANT tes modifications :**
âŒ URI contenait la query string : "/hello.py?name=test"
âŒ CGI recevait QUERY_STRING="" (vide)
âŒ Chemins CGI foireux : "www/./www/hello.py"

**APRÃˆS tes modifications :**
âœ… URI propre : "/hello.py"
âœ… Query string sÃ©parÃ©e : "name=test"  
âœ… CGI reÃ§oit QUERY_STRING="name=test"
âœ… Chemins CGI corrects : chdir("./www") + script_name="hello.py"
âœ… Variables d'environnement CGI complÃ¨tes
âœ… Communication fork/pipe/exec standard