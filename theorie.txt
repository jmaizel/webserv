definition socket : 

les sockets sont la base de la communication reseau. c est comme une prise ou un point de connexion pour communiquer sur le reseau.
on l utilise comme points de passage pour faire passer des donnees.

--> annalogie simple, un socket c est comme une boite au letre, on peut envoyer des lettres ou en recevoir.

dans notre cas a nous on va utiliser des socket TCP qui vont connecter le client et le serveur. voici les avamtages :

- connexion fiable : si tu envoie "ABC" ca arrive "ABC"
- ordre garante : les donnees arrivent dans l ordre
- detection d erreurs : si ca se perd on le sait
- comme un appel telephonique : connexion etable, conversation , raccrochage 


SERVEUR                           CLIENT
┌─────────────┐                  ┌─────────────┐
│ Socket      │                  │ Socket      │
│ (écoute)    │                  │             │
│ 127.0.0.1   │ ←── connect ──── │ random_port │
│ :8080       │                  │             │
└─────────────┘                  └─────────────┘
       │
       │ accept() crée un nouveau socket
       ▼
┌─────────────┐
│ Socket      │ ←── recv/send ──→ Client
│ (client)    │
│ fd = 5      │
└─────────────┘


Alice                    Bob
┌─────┐                ┌─────┐
│     │ ←── LIGNE ───→ │     │
└─────┘    (socket)    └─────┘
  ↑                      ↑
"Salut Bob!"         "Salut Alice!"
(les données)        (les données)


==> ligne pour creer le socket :

 _server_fd = socket(AF_INET, SOCK_STREAM, 0);
 AF_INET = IPV4
 SOCK_STREAM = TCP (connexion fiable)







ce qu il va se passe , a la creation de l objet server , on vide completement les fd_set mais on a aucun socket , les fd_set sont prets mais vides. et quand
on lance le serveur : 
server.ft_init_server();      // ICI on crée le socket
server.ft_start_listening();  // ICI on ajoute le socket aux fd_set


on doit initialise les fd_set dans le constructer car les fd_set contiennent des bits aleatoires en memoire au debut , donc si on ne les initialise pas a 0 on 
peut avoir des problemes.



explication des methodes : 

LA METHODE GET : 

get est la methode HTTP la plus simple, elle dit "donne moi la ressource qui se trouve a cette adresse". GET est donc un protoal HTTP pour demander une ressource.

- exemple d une requete GET :

GET /about.html HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0...
Accept: text/html,application/xhtml+xml...
Connection: keep-alive

[corps vide - GET n'a jamais de body]

- exemple d une reponse GET :

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 226
Date: Thu, 12 Jun 2025 14:30:00 GMT

<!DOCTYPE html>
<html>
<head>...
[contenu du fichier]

--> les 3 technologies fondamentales que le navigateur web peut interpreter nativement : du hTML ( role structure et contenu de la page)
du CSS (Apparence et mise en page), JAVASCRIPT (interactivite et logique)

Dans webServ, on fait une requete script, Webserv execute python et c est python qui genere/formate le HTML



┌─────────────────────────────────────────────────────────────────────────────┐
│                            🚀 DÉMARRAGE DU SERVEUR                          │
└─────────────────────────────────────────────────────────────────────────────┘

1️⃣ main.cpp lance le serveur
   ├── Vérifie les arguments (config.conf)
   ├── parseConfigFile() → Parse le fichier de configuration
   │   ├── Lit server { listen, server_name, root, index, allowed_methods }
   │   └── Lit location { path, root, index, allowed_methods, client_max_body_size }
   ├── ft_print_config() → Affiche la configuration parsée de manière claire
   └── Crée Server(config) avec la configuration complète

2️⃣ Server::ft_init_server()
   ├── socket() → Crée le socket TCP
   ├── setsockopt(SO_REUSEADDR) → Permet de redémarrer rapidement
   ├── fcntl(O_NONBLOCK) → Socket non-bloquant
   ├── bind() → Lie le socket au port (_config.listen)
   └── Configuration depuis _config au lieu de valeurs en dur

3️⃣ Server::ft_start_listening()
   ├── listen() → Met le socket en écoute
   ├── FD_SET() → Ajoute le socket au fd_set
   └── Affiche "Server listening on {server_name}:{port}"

┌─────────────────────────────────────────────────────────────────────────────┐
│                       🔄 BOUCLE PRINCIPALE DU SERVEUR                       │
└─────────────────────────────────────────────────────────────────────────────┘

4️⃣ Server::ft_handle_connections() - BOUCLE INFINIE
   ├── select() → Attend des événements sur les sockets
   ├── Parcourt tous les file descriptors
   └── Pour chaque socket actif :
       ├── Si c'est _server_fd → ft_accept_new_client()
       └── Sinon → ft_handle_client_request(client_fd)

┌─────────────────────────────────────────────────────────────────────────────┐
│                         🤝 GESTION D'UNE NOUVELLE CONNEXION                 │
└─────────────────────────────────────────────────────────────────────────────┘

5️⃣ Server::ft_accept_new_client()
   ├── accept() → Accepte la connexion client
   ├── fcntl(O_NONBLOCK) → Rend le socket client non-bloquant
   ├── FD_SET() → Ajoute le client au fd_set de surveillance
   ├── _client_fds.push_back() → Stocke le fd client
   └── Met à jour _max_fd si nécessaire

┌─────────────────────────────────────────────────────────────────────────────┐
│                      📨 TRAITEMENT D'UNE REQUÊTE CLIENT                      │
└─────────────────────────────────────────────────────────────────────────────┘

6️⃣ Server::ft_handle_client_request(client_fd)
   │
   ├── recv() → Reçoit les données brutes du client
   │   └── Exemple : "GET /hello.py?name=test HTTP/1.1\r\nHost: localhost..."
   │
   ├── ft_is_request_complete() → Vérifie si la requête est complète
   │   ├── Cherche "\r\n\r\n" (fin des headers)
   │   ├── Pour GET/DELETE : OK si headers complets
   │   └── Pour POST : Vérifie que le body est complet selon Content-Length
   │
   ├── ft_parse_http_request() → PARSING COMPLET DE LA REQUÊTE
   │   │
   │   ├── 📝 ft_parse_request_line() **⭐ MODIFIÉ !**
   │   │   ├── Sépare "GET /hello.py?name=test HTTP/1.1"
   │   │   ├── Valide method ∈ {GET, POST, DELETE}
   │   │   ├── Valide version = "HTTP/1.1"
   │   │   ├── **NOUVEAU** : Sépare URI et query string
   │   │   │   ├── Si '?' trouvé → uri="/hello.py", query_string="name=test"
   │   │   │   └── Sinon → uri="/hello.py", query_string=""
   │   │   └── Stocke : request.method, request.uri, request.query_string, request.version
   │   │
   │   ├── 📋 ft_parse_headers()
   │   │   ├── Parse chaque ligne "Key: Value"
   │   │   ├── Trim les espaces
   │   │   ├── Convertit les clés en minuscules
   │   │   └── Stocke dans request.headers["key"] = "value"
   │   │
   │   └── Pour POST : Extrait le body selon Content-Length
   │       └── Stocke dans request.body
   │
   └── ft_handle_request_with_config(method, uri, body) → TRAITEMENT AVEC CONFIG

┌─────────────────────────────────────────────────────────────────────────────┐
│                    ⚙️ TRAITEMENT AVEC CONFIGURATION                          │
└─────────────────────────────────────────────────────────────────────────────┘

7️⃣ Server::ft_handle_request_with_config(method, uri, body)
   │
   ├── 🎯 ft_find_location(uri) → Trouve la location qui match
   │   ├── Parcourt _config.locations[]
   │   ├── Vérifie si uri.find(location.path) == 0
   │   └── Prend la location avec le path le plus long (plus précise)
   │   
   ├── ✅ ft_is_method_allowed(method, location)
   │   ├── Utilise location->allowed_methods si existe
   │   ├── Sinon utilise _config.allowed_methods
   │   └── Retourne true/false selon si method est autorisée
   │
   └── Router selon la méthode :
       ├── GET → ft_serve_static_file_with_config(uri)
       ├── POST → ft_handle_post_request_with_config(uri, body)
       └── DELETE → ft_handle_delete(uri)

┌─────────────────────────────────────────────────────────────────────────────┐
│                        📁 SERVIR UN FICHIER STATIQUE                        │
└─────────────────────────────────────────────────────────────────────────────┘

8️⃣ Server::ft_serve_static_file_with_config(uri) **⭐ MODIFIÉ !**
   │
   ├── 🎯 ft_find_location(uri) → Re-trouve la location
   │
   ├── 📂 ft_get_file_path(uri, location) → CONSTRUCTION DU CHEMIN
   │   │
   │   ├── Détermine root et index :
   │   │   ├── Si location existe : location->root ou _config.root
   │   │   └── Sinon : _config.root et _config.index
   │   │
   │   ├── Construction du chemin :
   │   │   ├── Si uri == "/" → root + "/" + index
   │   │   ├── Si fichier avec extension → root + uri
   │   │   ├── Si location et uri match location->path → 
   │   │   │   └── Enlève le path de location de l'URI
   │   │   └── Sinon → root + uri
   │   │
   │   └── Exemples :
   │       ├── uri="/" → "./www/index.html"
   │       ├── uri="/hello.py" → "./www/hello.py"
   │       └── uri="/cgi-bin/script.py" → "./www/cgi-bin/script.py"
   │
   ├── 🐍 **NOUVEAU** : Détection CGI améliorée
   │   │   Si file_path se termine par ".py" :
   │   │   ├── Crée un HttpRequest basique pour CGI
   │   │   ├── cgi_request.method = "GET"
   │   │   ├── cgi_request.uri = uri (sans query string)
   │   │   ├── **Extrait la query string de l'URI original**
   │   │   │   ├── Si uri contient '?' → sépare URI et query
   │   │   │   └── cgi_request.query_string = "name=test"
   │   │   └── ft_execute_cgi(file_path, cgi_request) **avec HttpRequest**
   │
   ├── 📖 ft_read_file_simple(file_path) → Lit le fichier
   │   ├── ifstream(file_path) → Ouvre le fichier
   │   ├── getline() en boucle → Lit ligne par ligne
   │   └── Retourne le contenu ou "" si erreur
   │
   ├── 🏷️ ft_get_content_type(file_path) → Détermine le MIME type
   │   ├── Trouve l'extension (.html, .css, .js, .png...)
   │   └── Retourne le Content-Type approprié
   │
   └── 📤 Construction de la réponse HTTP :
       ├── "HTTP/1.1 200 OK\r\n"
       ├── "Content-Type: text/html\r\n"
       ├── "Content-Length: 1234\r\n"
       ├── "Server: WebServ/1.0\r\n"
       ├── "Connection: close\r\n"
       ├── "\r\n"
       └── [contenu du fichier]

┌─────────────────────────────────────────────────────────────────────────────┐
│                       🐍 EXÉCUTION CGI COMPLÈTE **⭐ NOUVEAU !**            │
└─────────────────────────────────────────────────────────────────────────────┘

9️⃣ Server::ft_execute_cgi(script_path, HttpRequest& request) **VERSION AVANCÉE**
   │
   ├── 🔧 Création des pipes
   │   ├── pipe(pipe_in) → Communication serveur → script (stdin)
   │   └── pipe(pipe_out) → Communication script → serveur (stdout)
   │
   ├── 🍴 fork() → Crée un processus enfant dédié au script
   │
   ├── 👶 **PROCESSUS ENFANT** (le script Python) :
   │   │
   │   ├── 🔀 Redirection des flux
   │   │   ├── dup2(pipe_in[0], STDIN_FILENO) → stdin = pipe du parent
   │   │   └── dup2(pipe_out[1], STDOUT_FILENO) → stdout = pipe vers parent
   │   │
   │   ├── 🌍 **Variables d'environnement CGI** (standard complet) :
   │   │   ├── setenv("REQUEST_METHOD", "GET", 1)
   │   │   ├── setenv("QUERY_STRING", "name=test", 1) **⭐ CORRIGÉ !**
   │   │   ├── setenv("SERVER_NAME", "localhost", 1)
   │   │   ├── setenv("SERVER_PORT", "8080", 1)
   │   │   ├── setenv("SCRIPT_NAME", "./www/hello.py", 1)
   │   │   ├── setenv("SERVER_PROTOCOL", "HTTP/1.1", 1)
   │   │   ├── setenv("GATEWAY_INTERFACE", "CGI/1.1", 1)
   │   │   └── Pour POST : setenv("CONTENT_LENGTH", body_size, 1)
   │   │
   │   ├── 📂 **Gestion des chemins corrigée** :
   │   │   ├── chdir("./www") → Change vers le répertoire www
   │   │   ├── Si script_path = "./www/hello.py" → script_name = "hello.py"
   │   │   └── Évite le double "./www/./www/" dans les chemins
   │   │
   │   ├── 🚀 execve("/usr/bin/python3", ["python3", "hello.py"], environ)
   │   └── Si execve échoue → exit(1)
   │
   └── 👨‍💻 **PROCESSUS PARENT** (ton serveur) :
       │
       ├── 📤 Si POST : write(pipe_in[1], request.body) → Envoie données au script
       ├── 📖 read(pipe_out[0], buffer) → Lit la sortie du script en boucle
       ├── ⏳ waitpid(pid, &status, 0) → Attend que le script se termine
       ├── ✅ Vérifie WEXITSTATUS(status) == 0 → Script terminé correctement
       └── ft_build_cgi_response(cgi_output) → Construit la réponse HTTP

┌─────────────────────────────────────────────────────────────────────────────┐
│                   🐍 CE QUI SE PASSE DANS LE SCRIPT PYTHON                  │
└─────────────────────────────────────────────────────────────────────────────┘

🔟 Dans hello.py (processus enfant séparé) :
   │
   ├── 📖 Le script lit les variables d'environnement :
   │   ├── os.environ.get('REQUEST_METHOD') → "GET"
   │   ├── os.environ.get('QUERY_STRING') → "name=test" **⭐ MAINTENANT ÇA MARCHE !**
   │   ├── os.environ.get('SERVER_NAME') → "localhost"
   │   └── Si POST : sys.stdin.read(content_length) → Lit le body
   │
   ├── 📝 Le script génère sa réponse :
   │   ├── print("Content-Type: text/html") → Header CGI
   │   ├── print("") → Ligne vide obligatoire
   │   └── print("<html>...") → Body HTML
   │
   └── 📤 Sortie du script (via stdout = pipe vers parent) :
       └── "Content-Type: text/html\n\n<html><body>...</body></html>"

┌─────────────────────────────────────────────────────────────────────────────┐
│                       📤 CONSTRUCTION DE LA RÉPONSE HTTP                    │
└─────────────────────────────────────────────────────────────────────────────┘

1️⃣1️⃣ Server::ft_build_cgi_response(cgi_output) **⭐ MODIFIÉ !**
   │
   ├── 🔍 Cherche le séparateur headers/body dans la sortie CGI
   │   ├── Cherche "\n\n" ou "\r\n\r\n"
   │   ├── cgi_headers = "Content-Type: text/html"
   │   └── cgi_body = "<html><body>...</body></html>"
   │
   ├── 🔧 Normalise les headers CGI (convertit \n en \r\n)
   │
   └── 📦 Construit la réponse HTTP complète :
       ├── "HTTP/1.1 200 OK\r\n"
       ├── "Content-Type: text/html\r\n" (du script)
       ├── "Content-Length: 156\r\n" (calculé automatiquement)
       ├── "Server: WebServ/1.0\r\n"
       ├── "Connection: close\r\n"
       ├── "\r\n"
       └── "<html><body>...</body></html>" (du script)

┌─────────────────────────────────────────────────────────────────────────────┐
│                          📤 ENVOI DE LA RÉPONSE                             │
└─────────────────────────────────────────────────────────────────────────────┘

1️⃣2️⃣ Retour dans ft_handle_client_request()
   ├── send(client_fd, response) → Envoie la réponse HTTP au client
   └── ft_disconnect_client() → Ferme la connexion
       ├── close(client_fd) → Ferme le socket
       ├── FD_CLR() → Retire de la surveillance
       └── Supprime de _client_fds

┌─────────────────────────────────────────────────────────────────────────────┐
│                             🔄 RETOUR EN BOUCLE                             │
└─────────────────────────────────────────────────────────────────────────────┘

Le serveur retourne en boucle à l'étape 4️⃣ et attend la prochaine connexion...

┌─────────────────────────────────────────────────────────────────────────────┐
│                    📊 EXEMPLE COMPLET : curl "/hello.py?name=test"          │
└─────────────────────────────────────────────────────────────────────────────┘

1. **curl envoie** : "GET /hello.py?name=test HTTP/1.1\r\nHost: localhost:8080\r\n\r\n"

2. **ft_parse_request_line()** sépare :
   ├── method = "GET"
   ├── uri = "/hello.py" (sans query string !)
   ├── query_string = "name=test" 
   └── version = "HTTP/1.1"

3. **ft_serve_static_file_with_config()** :
   ├── file_path = "./www/hello.py"
   ├── Détecte ".py" → CGI !
   ├── Crée HttpRequest avec query_string = "name=test"
   └── ft_execute_cgi("./www/hello.py", request)

4. **CGI fork()** :
   ├── **Enfant** : 
   │   ├── chdir("./www")
   │   ├── setenv("QUERY_STRING", "name=test", 1)
   │   └── execve("python3", ["hello.py"])
   └── **Parent** : attend et lit la sortie

5. **hello.py** lit os.environ['QUERY_STRING'] = "name=test" ✅

6. **Script génère** : "Content-Type: text/html\n\n<h1>Hello!</h1><p>Query: name=test</p>"

7. **ft_build_cgi_response()** construit la réponse HTTP complète

8. **send()** envoie au client qui reçoit le HTML avec "Query: name=test" ✅

┌─────────────────────────────────────────────────────────────────────────────┐
│                          🎯 DIFFÉRENCES PRINCIPALES                         │
└─────────────────────────────────────────────────────────────────────────────┘

**AVANT tes modifications :**
❌ URI contenait la query string : "/hello.py?name=test"
❌ CGI recevait QUERY_STRING="" (vide)
❌ Chemins CGI foireux : "www/./www/hello.py"

**APRÈS tes modifications :**
✅ URI propre : "/hello.py"
✅ Query string séparée : "name=test"  
✅ CGI reçoit QUERY_STRING="name=test"
✅ Chemins CGI corrects : chdir("./www") + script_name="hello.py"
✅ Variables d'environnement CGI complètes
✅ Communication fork/pipe/exec standard