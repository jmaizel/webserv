#include "Server.hpp"
#include <sstream>

// Constructeur par défaut
Server::Server(void) : _server_fd(-1), _max_fd(0), _port(8080), _host("127.0.0.1")
{
	// Initialiser tous les fd_set à vide
	FD_ZERO(&_master_fds);
	FD_ZERO(&_read_fds);
	FD_ZERO(&_write_fds);
}

// Constructeur avec paramètres
Server::Server(int port, const std::string& host) : _server_fd(-1), _max_fd(0), _port(port), _host(host)
{
	FD_ZERO(&_master_fds);
	FD_ZERO(&_read_fds);
	FD_ZERO(&_write_fds);
}

// Constructeur de copie
Server::Server(const Server& other)
{
	*this = other;  // Utilise l'opérateur d'assignation
}

// Destructeur
Server::~Server(void)
{
	// Fermer le socket serveur s'il existe
	if (_server_fd != -1)
		close(_server_fd);
	
	// Fermer tous les sockets clients
	size_t i = 0;
	while (i < _client_fds.size())
	{
		close(_client_fds[i]);
		i++;
	}
}

// Opérateur d'assignation
Server& Server::operator=(const Server& other)
{
	if (this != &other)  // Protection contre l'auto-assignation
	{
		_server_fd = other._server_fd;
		_address = other._address;
		_max_fd = other._max_fd;
		_client_fds = other._client_fds;
		_port = other._port;
		_host = other._host;
		_master_fds = other._master_fds;
		_read_fds = other._read_fds;
		_write_fds = other._write_fds;
	}
	return (*this);
}

void Server::ft_init_server(void)
{
	// 1. Créer le socket
	_server_fd = socket(AF_INET, SOCK_STREAM, 0);
	if (_server_fd == -1)
		throw std::runtime_error("Socket creation failed");
	
	// 2. Option SO_REUSEADDR (très important !)
	int opt = 1;
	if (setsockopt(_server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
		throw std::runtime_error("Setsockopt failed");
	
	// 3. Rendre le socket non-bloquant
	if (fcntl(_server_fd, F_SETFL, O_NONBLOCK) < 0)
		throw std::runtime_error("Fcntl failed");

	// 4. Configurer l'adresse du serveur
	_address.sin_family = AF_INET;
	_address.sin_port = htons(_port);
	_address.sin_addr.s_addr = inet_addr(_host.c_str());

	// 5. Attacher le socket à l'adresse (bind)
	if (bind(_server_fd, (struct sockaddr*)&_address, sizeof(_address)) < 0)
		throw std::runtime_error("Bind failed");
}

void Server::ft_start_listening(void)
{
	// 1. Mettre le socket en mode écoute
	if (listen(_server_fd, MAX_CLIENTS) < 0)
		throw std::runtime_error("Listen failed");
	
	// 2. Ajouter le socket serveur au fd_set principal
	FD_SET(_server_fd, &_master_fds);
	_max_fd = _server_fd;

	std::cout << "Server listening on " << _host << ":" << _port << std::endl;
}

void Server::ft_handle_connections(void)
{
	while (true)  // Boucle infinie du serveur
	{
		// 1. Copier master_fds dans read_fds (select() modifie read_fds)
		_read_fds = _master_fds;

		// 2. select() attend qu'au moins un socket ait des données
		if (select(_max_fd + 1, &_read_fds, NULL, NULL, NULL) < 0)
			throw std::runtime_error("Select failed");

		// 3. Parcourir TOUS les file descriptors possibles
		int i = 0;
		while (i <= _max_fd)
		{
			// 4. Vérifier si ce fd a des données à lire
			if (FD_ISSET(i, &_read_fds))
			{
				if (i == _server_fd)
				{
					// C'est le socket serveur → nouvelle connexion
					ft_accept_new_client();
				}
				else
				{
					// C'est un client → données à traiter
					ft_handle_client_request(i);
				}
			}
			i++;
		}
	}
}

void Server::ft_accept_new_client(void)
{
	// 1. Préparer la structure pour l'adresse du client
	struct sockaddr_in client_addr;
	socklen_t client_len = sizeof(client_addr);

	// 2. Accepter la connexion
	int client_fd = accept(_server_fd, (struct sockaddr*)&client_addr, &client_len);
	if (client_fd < 0)
	{
		// Pas d'erreur grave, juste pas de client maintenant
		return;
	}

	// 3. Rendre le socket client non-bloquant aussi
	if (fcntl(client_fd, F_SETFL, O_NONBLOCK) < 0)
	{
		close(client_fd);  // Fermer si on peut pas configurer
		return;
	}

	// 4. Ajouter le nouveau client à notre surveillance
	FD_SET(client_fd, &_master_fds);
	_client_fds.push_back(client_fd);
	
	// 5. Mettre à jour le max_fd si nécessaire
	if (client_fd > _max_fd)
		_max_fd = client_fd;

	std::cout << "New client connected: " << client_fd << std::endl;
}

void Server::ft_handle_client_request(int client_fd)
{
	char buffer[BUFFER_SIZE];
	ssize_t bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
	
	if (bytes_read <= 0)
	{
		std::cout << "Client disconnected: " << client_fd << std::endl;
		close(client_fd);
		FD_CLR(client_fd, &_master_fds);
		
		size_t i = 0;
		while (i < _client_fds.size())
		{
			if (_client_fds[i] == client_fd)
			{
				_client_fds.erase(_client_fds.begin() + i);
				break;
			}
			i++;
		}
		return;
	}

	buffer[bytes_read] = '\0';
	std::string raw_data(buffer);
	
	// Parser minimal pour extraire l'URI
	std::string uri = "/";
	size_t first_line_end = raw_data.find("\r\n");
	if (first_line_end != std::string::npos)
	{
		std::string request_line = raw_data.substr(0, first_line_end);
		std::istringstream iss(request_line);
		std::string method, version;
		iss >> method >> uri >> version;
	}
	
	std::cout << "Request: " << uri << std::endl;
	
	// Utiliser notre handler intelligent
	std::string response = ft_handle_request_simple(uri);
	
	send(client_fd, response.c_str(), response.length(), 0);
}

std::string Server::ft_execute_cgi(const std::string& script_path)
{
	// Construire la commande
	std::string command = "python3 " + script_path;
	
	// Exécuter le script et capturer sa sortie
	FILE* pipe = popen(command.c_str(), "r");
	if (!pipe)
		return "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 13\r\n\r\nScript failed";
	
	// Lire la sortie ligne par ligne
	std::string result;
	char buffer[1024];
	while (fgets(buffer, sizeof(buffer), pipe) != NULL)
	{
		result += buffer;
	}
	pclose(pipe);
	
	// Séparer headers et body du script
	size_t body_start = result.find("\r\n\r\n");
	if (body_start == std::string::npos)
		return "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 17\r\n\r\nMalformed script";
	
	std::string script_headers = result.substr(0, body_start + 2); // Garde \r\n
	std::string body = result.substr(body_start + 4); // Skip \r\n\r\n
	
	// Calculer Content-Length du body
	std::ostringstream oss;
	oss << body.length();
	
	// Construire la réponse complète
	std::string response = "HTTP/1.1 200 OK\r\n";
	response += script_headers; // Headers du script (Content-Type, etc.)
	response += "Content-Length: " + oss.str() + "\r\n";
	response += "\r\n";
	response += body;
	
	return response;
}

std::string Server::ft_handle_request_simple(const std::string& uri)
{
	// Si l'URI finit par .py, c'est un script
	if (uri.length() > 3 && uri.substr(uri.length() - 3) == ".py")
	{
		std::string script_path = "./www" + uri;
		return ft_execute_cgi(script_path);
	}
	
	// Sinon, réponse basique
	std::string body = "<html><body>";
	body += "<h1>WebServ fonctionne!</h1>";
	body += "<p><a href='/cgi-bin/time.py'>Voir l'heure (script Python)</a></p>";
	body += "</body></html>";
	
	// Convertir la taille en string (compatible C++98)
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 200 OK\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n";
	response += "\r\n";
	response += body;
	
	return response;
}#include "Server.hpp"
#include <iostream>
#include <cstdlib>  // Pour atoi()
#include "../../includes/ServerConfig.hpp"

int main(int ac, char** av) {
	(void)ac;
    ServerConfig config = parseConfigFile(av[1]);

    std::cout << "Server configuration:" << std::endl;
    std::cout << "  Port: " << config.listen << std::endl;
    std::cout << "  Server name: " << config.server_name << std::endl;
    std::cout << "  Root: " << config.root << std::endl;
    std::cout << "  Index: " << config.index << std::endl;
    std::cout << "  Allowed methods: ";
    for (size_t i = 0; i < config.allowed_methods.size(); i++) {
        std::cout << config.allowed_methods[i] << " ";
    }
    std::cout << std::endl;

    std::cout << std::endl << "Locations:" << std::endl;
    for (size_t i = 0; i < config.locations.size(); i++) {
        const LocationConfig& loc = config.locations[i];
        std::cout << "  Location " << i << ":" << std::endl;
        std::cout << "    Path: " << loc.path << std::endl;
        std::cout << "    Root: " << loc.root << std::endl;
        std::cout << "    Index: " << loc.index << std::endl;
        std::cout << "    Allowed methods: ";
        for (size_t j = 0; j < loc.allowed_methods.size(); j++) {
            std::cout << config.allowed_methods[i] << " ";
        }
        std::cout << std::endl;
        std::cout << "    Client max body size: " << loc.client_max_body_size << std::endl;
        std::cout << std::endl;
    }
	try
	{

		std::cout << "Starting WebServ..." << std::endl;
		
		// Créer le serveur
		Server server(config.listen, config.server_name);
		
		// Étapes d'initialisation
		server.ft_init_server();
		server.ft_start_listening();
		
		std::cout << "Server ready! Try: http://localhost:" << config.listen << std::endl;
		
		// Boucle principale (bloque ici)
		server.ft_handle_connections();
	}
	catch (const std::exception& e)
	{
		std::cerr << "Error: " << e.what() << std::endl;
		return (1);
	}

	return (0);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Parser.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 11:36:48 by mwattier          #+#    #+#             */
/*   Updated: 2025/06/12 14:17:33 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/ServerConfig.hpp"

void parseDirective(const std::string& line, ServerConfig& config) {
    std::istringstream iss(line);
    std::string key, value;
    iss >> key;
    if (key == "listen") {
        iss >> config.listen;
    } else if (key == "server_name") {
        iss >> config.server_name;
    } else if (key == "root") {
        iss >> config.root;
    } else if (key == "index") {
        iss >> config.index;
    } else if (key == "allowed_methods") {
        std::string method;
        while (iss >> method) {
            config.allowed_methods.push_back(method);
        }
    }
    // Ajoute d'autres directives selon tes besoins
}

void parseLocation(std::ifstream& file, ServerConfig& config) {
    LocationConfig loc;
    std::string line, key, value;
    // Lire la première ligne pour le path
    std::getline(file, line);
    std::istringstream iss(line);
    iss >> key >> loc.path;
    // Lire les directives du bloc location
    while (std::getline(file, line)) {
        if (line.find("}") != std::string::npos) break; // Fin du bloc
        std::istringstream iss(line);
        iss >> key;
        if (key == "root") {
            iss >> loc.root;
        } else if (key == "index") {
            iss >> loc.index;
        } else if (key == "allowed_methods") {
            std::string method;
            while (iss >> method) {
                loc.allowed_methods.push_back(method);
            }
        } else if (key == "client_max_body_size") {
            iss >> loc.client_max_body_size;
        }
    }
    config.locations.push_back(loc);
}

ServerConfig parseConfigFile(const std::string& filename) {
    std::ifstream file(filename);
    ServerConfig config;
    std::string line;

    while (std::getline(file, line)) {
        // Supprimer les espaces en début de ligne
        line.erase(line.begin(), std::find_if(line.begin(), line.end(), [](int ch) { return !std::isspace(ch); }));
        if (line.empty() || line[0] == '#') continue; // Ignore les commentaires et lignes vides

        if (line.find("server {") != std::string::npos) {
            // On est dans le bloc server, on continue
        } else if (line.find("location") != std::string::npos) {
            parseLocation(file, config);
        } else if (line.find("}") != std::string::npos) {
            // Fin du bloc, on continue
        } else {
            parseDirective(line, config);
        }
    }
    return config;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerConfig.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 11:35:25 by mwattier          #+#    #+#             */
/*   Updated: 2025/06/12 14:17:02 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <sstream>
#include <algorithm>

struct LocationConfig {
    std::string path;
    std::string root;
    std::string index;
    std::vector<std::string> allowed_methods;
    int client_max_body_size;
};

struct ServerConfig {
    int listen;
    std::string server_name;
    std::string root;
    std::string index;
    std::vector<std::string> allowed_methods;
    std::vector<LocationConfig> locations;
    std::map<int, std::string> error_pages;
};

ServerConfig parseConfigFile(const std::string& filename);#ifndef SERVER_HPP
# define SERVER_HPP

# include <sys/socket.h>
# include <netinet/in.h>
# include <arpa/inet.h>
# include <sys/select.h>
# include <unistd.h>
# include <fcntl.h>
# include <iostream>
# include <vector>
# include <map>
# include <string>
# include <stdexcept>
# include <sstream>
# include <cstdio>

# define MAX_CLIENTS 1024
# define BUFFER_SIZE 4096

class Server
{
	private:
		int					_server_fd;
		struct sockaddr_in	_address;
		fd_set				_read_fds;
		fd_set				_write_fds;
		fd_set				_master_fds;
		int					_max_fd;
		std::vector<int>	_client_fds;
		int					_port;
		std::string			_host;

	public:
		// Classe canonique
		Server(void);
		Server(int port, const std::string& host);
		Server(const Server& other);
		~Server(void);
		Server& operator=(const Server& other);

		// Methodes principales
		void	ft_init_server(void);
		void	ft_start_listening(void);
		void	ft_handle_connections(void);
		void	ft_accept_new_client(void);
		void	ft_handle_client_request(int client_fd);
		
		// Methodes CGI temporaires
		std::string	ft_execute_cgi(const std::string& script_path);
		std::string	ft_handle_request_simple(const std::string& uri);
};

#endif