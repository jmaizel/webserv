#include "../../includes/Server.hpp"

// Trouve la location qui correspond le mieux à l'URI
const LocationConfig* Server::ft_find_location(const std::string& uri)
{
	const LocationConfig* best_match = NULL;
	size_t best_match_length = 0;
	
	// Parcourir toutes les locations configurées
	size_t i = 0;
	while (i < _config.locations.size())
	{
		const LocationConfig& location = _config.locations[i];
		
		// Vérifier si l'URI commence par le path de cette location
		if (uri.find(location.path) == 0)
		{
			// Prendre la location avec le path le plus long (plus précise)
			if (location.path.length() > best_match_length)
			{
				best_match = &location;
				best_match_length = location.path.length();
			}
		}
		i++;
	}
	
	return best_match;
}

// Vérifie si une méthode HTTP est autorisée
bool Server::ft_is_method_allowed(const std::string& method, const LocationConfig* location)
{
	const std::vector<std::string>* allowed_methods;
	
	// Utiliser les méthodes de la location si elle existe, sinon celles du serveur
	if (location && !location->allowed_methods.empty())
		allowed_methods = &location->allowed_methods;
	else
		allowed_methods = &_config.allowed_methods;
	
	// Si aucune restriction définie, autoriser GET par défaut
	if (allowed_methods->empty())
		return (method == "GET");
	
	// Vérifier si la méthode est dans la liste
	size_t i = 0;
	while (i < allowed_methods->size())
	{
		if ((*allowed_methods)[i] == method)
			return true;
		i++;
	}
	
	return false;
}

// Construit le chemin complet du fichier selon la config
std::string Server::ft_get_file_path(const std::string& uri, const LocationConfig* location)
{
	std::string root;
	std::string index;
	
	// Utiliser root et index de la location si elle existe
	if (location)
	{
		root = location->root.empty() ? _config.root : location->root;
		index = location->index.empty() ? _config.index : location->index;
		
		std::cout << "Using location config - root: " << root << ", index: " << index << std::endl;
	}
	else
	{
		root = _config.root;
		index = _config.index;
		
		std::cout << "Using server config - root: " << root << ", index: " << index << std::endl;
	}
	
	// Construire le chemin
	std::string file_path = root;
	
	if (uri == "/")
	{
		// Page d'accueil
		if (file_path[file_path.length() - 1] != '/')
			file_path += "/";
		file_path += index;
	}
	else
	{
		// Pour les fichiers spécifiques, utiliser l'URI tel quel
		// Ne pas essayer d'enlever le path de la location pour les fichiers .html, .css, etc.
		if (uri.find(".") != std::string::npos)
		{
			// C'est un fichier avec extension → utiliser l'URI directement
			file_path += uri;
		}
		else if (location && !location->path.empty() && uri.find(location->path) == 0)
		{
			// C'est un path de location sans extension → traitement spécial
			std::string relative_path = uri.substr(location->path.length());
			if (!relative_path.empty() && relative_path[0] == '/')
				relative_path = relative_path.substr(1);
			
			if (file_path[file_path.length() - 1] != '/' && !relative_path.empty())
				file_path += "/";
			file_path += relative_path;
		}
		else
		{
			// Pas de location spécifique, utiliser l'URI tel quel
			file_path += uri;
		}
	}
	
	return file_path;
}
#include "../../includes/Server.hpp"

// Constructeur par défaut
Server::Server(void) : _server_fd(-1), _max_fd(0)
{
	// Configuration par défaut
	_config.listen = 8080;
	_config.server_name = "localhost";
	_config.root = "./www";
	_config.index = "index.html";
	
	// Initialiser tous les fd_set à vide
	FD_ZERO(&_master_fds);
	FD_ZERO(&_read_fds);
	FD_ZERO(&_write_fds);
}

// Constructeur avec configuration
Server::Server(const ServerConfig& config) : _server_fd(-1), _max_fd(0), _config(config)
{
	FD_ZERO(&_master_fds);
	FD_ZERO(&_read_fds);
	FD_ZERO(&_write_fds);
}

// Constructeur de copie
Server::Server(const Server& other)
{
	*this = other;  // Utilise l'opérateur d'assignation
}

// Destructeur
Server::~Server(void)
{
	// Fermer le socket serveur s'il existe
	if (_server_fd != -1)
		close(_server_fd);
	
	// Fermer tous les sockets clients
	size_t i = 0;
	while (i < _client_fds.size())
	{
		close(_client_fds[i]);
		i++;
	}
}

// Opérateur d'assignation
Server& Server::operator=(const Server& other)
{
	if (this != &other)  // Protection contre l'auto-assignation
	{
		_server_fd = other._server_fd;
		_address = other._address;
		_max_fd = other._max_fd;
		_client_fds = other._client_fds;
		_config = other._config;  // Copier la config
		_master_fds = other._master_fds;
		_read_fds = other._read_fds;
		_write_fds = other._write_fds;
	}
	return (*this);
}

void Server::ft_init_server(void)
{
	// 1. Créer le socket
	_server_fd = socket(AF_INET, SOCK_STREAM, 0);
	if (_server_fd == -1)
		throw std::runtime_error("Socket creation failed");
	
	// 2. Option SO_REUSEADDR
	int opt = 1;
	if (setsockopt(_server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
		throw std::runtime_error("Setsockopt failed");
	
	// 3. Rendre le socket non-bloquant
	if (fcntl(_server_fd, F_SETFL, O_NONBLOCK) < 0)
		throw std::runtime_error("Fcntl failed");

	// 4. Configurer l'adresse du serveur AVEC LA CONFIG
	_address.sin_family = AF_INET;
	_address.sin_port = htons(_config.listen);  // Utilise _config.listen
	
	// Gérer "localhost" correctement
	if (_config.server_name == "localhost") {
		_address.sin_addr.s_addr = INADDR_ANY;
	} else {
		_address.sin_addr.s_addr = inet_addr(_config.server_name.c_str());
	}

	// 5. Attacher le socket à l'adresse (bind)
	if (bind(_server_fd, (struct sockaddr*)&_address, sizeof(_address)) < 0)
		throw std::runtime_error("Bind failed");
}

void Server::ft_start_listening(void)
{
	// 1. Mettre le socket en mode écoute
	if (listen(_server_fd, MAX_CLIENTS) < 0)
		throw std::runtime_error("Listen failed");
	
	// 2. Ajouter le socket serveur au fd_set principal
	FD_SET(_server_fd, &_master_fds);
	_max_fd = _server_fd;

	std::cout << "Server listening on " << _config.server_name << ":" << _config.listen << std::endl;
}

void Server::ft_handle_connections(void)
{
	while (true)  // Boucle infinie du serveur
	{
		// 1. Copier master_fds dans read_fds (select() modifie read_fds)
		_read_fds = _master_fds;

		// 2. select() attend qu'au moins un socket ait des données
		if (select(_max_fd + 1, &_read_fds, NULL, NULL, NULL) < 0)
			throw std::runtime_error("Select failed");

		// 3. Parcourir TOUS les file descriptors possibles
		int i = 0;
		while (i <= _max_fd)
		{
			// 4. Vérifier si ce fd a des données à lire
			if (FD_ISSET(i, &_read_fds))
			{
				if (i == _server_fd)
				{
					// C'est le socket serveur → nouvelle connexion
					ft_accept_new_client();
				}
				else
				{
					// C'est un client → données à traiter
					ft_handle_client_request(i);
				}
			}
			i++;
		}
	}
}
#include "../../includes/Server.hpp"
#include <sstream>

std::string Server::ft_serve_static_file(const std::string& uri)
{
	std::cout << "Trying to serve file for URI: " << uri << std::endl;
	
	// 1. Construire le chemin du fichier sur le système
	std::string file_path = "./www";   // Document root
	if (uri == "/") {
		file_path += "/index.html";    // Page par défaut
	} else {
		file_path += uri;              // Fichier demandé
	}
	
	// 2. Lire le contenu du fichier
	std::string file_content = ft_read_file_simple(file_path);
	
	// 3. Vérifier si le fichier existe
	if (file_content.empty()) {
		// Fichier introuvable → retourner 404
		return ft_build_404_response();
	}
	
	// 4. Déterminer le Content-Type selon l'extension
	std::string content_type = ft_get_content_type(file_path);
	
	// 5. Calculer Content-Length
	std::ostringstream oss;
	oss << file_content.length();
	
	// 6. Construire la réponse HTTP 200 OK
	std::string response = "HTTP/1.1 200 OK\r\n";
	response += "Content-Type: " + content_type + "\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += file_content;
	
	return response;
}

std::string Server::ft_read_file_simple(const std::string& file_path)
{
	std::cout << "Attempting to read file: " << file_path << std::endl;
	
	// 1. Ouvrir le fichier en lecture
	std::ifstream file(file_path.c_str());
	if (!file.is_open()) {
		std::cout << "Error: Cannot open file " << file_path << std::endl;
		return "";  // Retourner chaîne vide si échec
	}
	
	// 2. Lire le fichier ligne par ligne
	std::string content;
	std::string line;
	
	while (std::getline(file, line)) {
		content += line + "\n";  // Reconstituer le fichier
	}
	
	// 3. Fermer le fichier et afficher le résultat
	file.close();
	std::cout << "Successfully read " << content.length() << " bytes" << std::endl;
	return content;
}

std::string Server::ft_get_content_type(const std::string& file_path)
{
	// 1. Trouver l'extension du fichier
	size_t dot_pos = file_path.find_last_of('.');
	if (dot_pos == std::string::npos) {
		return "application/octet-stream";  // Type par défaut
	}
	
	std::string extension = file_path.substr(dot_pos);
	
	// 2. Déterminer le Content-Type selon l'extension
	if (extension == ".html" || extension == ".htm") {
		return "text/html";               // Pages web
	} else if (extension == ".css") {
		return "text/css";                // Feuilles de style
	} else if (extension == ".js") {
		return "application/javascript";  // Scripts JavaScript
	} else if (extension == ".png") {
		return "image/png";               // Images PNG
	} else if (extension == ".jpg" || extension == ".jpeg") {
		return "image/jpeg";              // Images JPEG
	} else if (extension == ".gif") {
		return "image/gif";               // Images GIF
	} else if (extension == ".ico") {
		return "image/x-icon";            // Favicons
	} else if (extension == ".txt") {
		return "text/plain";              // Fichiers texte
	} else if (extension == ".json") {
		return "application/json";        // Données JSON
	} else if (extension == ".pdf") {
		return "application/pdf";         // Documents PDF
	} else if (extension == ".zip") {
		return "application/zip";         // Archives
	} else {
		return "application/octet-stream"; // Type générique pour le reste
	}
}
#include "../../includes/Server.hpp"
#include "../../includes/HttpRequest.hpp"
#include <sstream>

HttpRequest ft_parse_http_request(const std::string& raw_data);
bool ft_is_request_complete(const std::string& data);

// NOUVELLE MÉTHODE : Traiter la requête avec la configuration ET le body
std::string Server::ft_handle_request_with_config(const std::string& method, const std::string& uri, const std::string& body)
{
	std::cout << "Processing " << method << " request for: " << uri << " with config" << std::endl;
	
	// 1. Trouver la location correspondante
	const LocationConfig* location = ft_find_location(uri);
	if (location)
		std::cout << "Matched location: " << location->path << " (root: " << location->root << ")" << std::endl;
	else
		std::cout << "No specific location, using server defaults" << std::endl;
	
	// 2. Vérifier si la méthode est autorisée
	if (!ft_is_method_allowed(method, location))
	{
		std::cout << "Method " << method << " not allowed for this location" << std::endl;
		return ft_build_405_response();
	}
	
	if (method == "GET")
	{
		return ft_serve_static_file_with_config(uri);
	}
	else if (method == "POST")
	{
		return ft_handle_post_request_with_config(uri, body);
	}
	else if (method == "DELETE")
	{
		return ft_handle_delete(uri);
	}
	else
	{
		return ft_build_405_response();
	}
}

// Gérer POST avec configuration
std::string Server::ft_handle_post_request_with_config(const std::string& uri, const std::string& body)
{
	std::cout << "Handling POST request for: " << uri << std::endl;
	std::cout << "POST body: " << body << std::endl;
	
	// 1. Vérifier la taille du body selon la config
	const LocationConfig* location = ft_find_location(uri);
	int max_body_size = location ? location->client_max_body_size : 1000000; // 1MB par défaut
	
	if (static_cast<int>(body.length()) > max_body_size)
	{
		std::cout << "POST body too large: " << body.length() << " > " << max_body_size << std::endl;
		return ft_build_413_response();
	}
	
	// 2. Parser les données POST (comme ton ami)
	std::map<std::string, std::string> post_params = ft_parse_post_data(body);
	
	// 3. Afficher les paramètres reçus
	std::cout << "POST parameters:" << std::endl;
	std::map<std::string, std::string>::iterator it;
	for (it = post_params.begin(); it != post_params.end(); ++it)
	{
		std::cout << "  " << it->first << " = " << it->second << std::endl;
	}
	
	// 4. Router selon l'URI
	if (uri == "/login")
	{
		return ft_handle_login(post_params);
	}
	else if (uri == "/upload")
	{
		return ft_handle_upload(post_params);
	}
	else if (uri == "/contact")
	{
		return ft_handle_contact(post_params);
	}
	else
	{
		return ft_build_post_success_response("POST reçu avec succès pour " + uri + " !");
	}
}

// Servir fichier statique avec la config
std::string Server::ft_serve_static_file_with_config(const std::string& uri)
{
	std::cout << "Serving static file for URI: " << uri << " with config" << std::endl;
	
	// 1. Trouver la location correspondante
	const LocationConfig* location = ft_find_location(uri);
	
	// 2. Construire le chemin du fichier selon la config
	std::string file_path = ft_get_file_path(uri, location);
	
	std::cout << "File path resolved to: " << file_path << std::endl;
	
	// 3. Vérifier si c'est un script CGI
	if (file_path.length() > 3 && file_path.substr(file_path.length() - 3) == ".py")
{
    std::cout << "Executing CGI script: " << file_path << std::endl;
    
    // Créer un HttpRequest basique pour le CGI
    HttpRequest cgi_request;
    cgi_request.method = "GET";
    cgi_request.uri = uri;
    cgi_request.version = "HTTP/1.1";
    cgi_request.is_valid = true;
    
    // Ajouter la query string si elle existe
    size_t query_pos = uri.find('?');
    if (query_pos != std::string::npos)
    {
        cgi_request.query_string = uri.substr(query_pos + 1);
    }
    
    return ft_execute_cgi(file_path, cgi_request);  // ← NOUVELLE VERSION
}
	
	// 4. Lire le contenu du fichier
	std::string file_content = ft_read_file_simple(file_path);
	
	// 5. Vérifier si le fichier existe
	if (file_content.empty())
	{
		std::cout << "File not found: " << file_path << std::endl;
		return ft_build_404_response();
	}
	
	// 6. Déterminer le Content-Type selon l'extension
	std::string content_type = ft_get_content_type(file_path);
	
	// 7. Calculer Content-Length
	std::ostringstream oss;
	oss << file_content.length();
	
	// 8. Construire la réponse HTTP 200 OK
	std::string response = "HTTP/1.1 200 OK\r\n";
	response += "Content-Type: " + content_type + "\r\n";
	response += "Content-Length: " + oss.str() + "\r\n";
	response += "Server: WebServ/1.0\r\n";
	response += "Connection: close\r\n";
	response += "\r\n";
	response += file_content;
	
	return response;
}

std::string Server::ft_handle_request_simple(const std::string& uri)
{
	// 1. Décision : script CGI ou fichier statique ?
	if (uri.length() > 3 && uri.substr(uri.length() - 3) == ".py")
{
    // C'est un script Python → exécuter via CGI
    std::string script_path = "./www" + uri;
    
    // Créer un HttpRequest basique
    HttpRequest cgi_request;
    cgi_request.method = "GET";
    cgi_request.uri = uri;
    cgi_request.version = "HTTP/1.1";
    cgi_request.is_valid = true;
    
    // Ajouter la query string si elle existe
    size_t query_pos = uri.find('?');
    if (query_pos != std::string::npos)
    {
        cgi_request.query_string = uri.substr(query_pos + 1);
    }
    
    return ft_execute_cgi(script_path, cgi_request);
}
	
	// 2. Sinon → fichier statique (HTML, CSS, JS, images...)
	return ft_serve_static_file(uri);
}

std::string Server::ft_get_directory_path(const std::string& file_path)
{
    // Trouver la dernière occurrence de '/'
    size_t last_slash = file_path.find_last_of('/');
    
    if (last_slash == std::string::npos)
    {
        // Pas de '/' trouvé, le fichier est dans le répertoire courant
        return "./";
    }
    
    if (last_slash == 0)
    {
        // Le '/' est au début, c'est la racine
        return "/";
    }
    
    // Retourner tout ce qui précède le dernier '/'
    return file_path.substr(0, last_slash);
}

std::string Server::ft_execute_cgi(const std::string& script_path, const HttpRequest& request)
{
    int pipe_in[2], pipe_out[2];
    
    // Créer les pipes pour communiquer avec le script
    if (pipe(pipe_in) == -1 || pipe(pipe_out) == -1)
        return ft_build_500_response();
    
    pid_t pid = fork();
    if (pid == -1)
    {
        close(pipe_in[0]); close(pipe_in[1]);
        close(pipe_out[0]); close(pipe_out[1]);
        return ft_build_500_response();
    }
    
    if (pid == 0) // Processus enfant = le script CGI
    {
        // Rediriger stdin et stdout vers les pipes
        dup2(pipe_in[0], STDIN_FILENO);   // Le script lira depuis pipe_in
        dup2(pipe_out[1], STDOUT_FILENO); // Le script écrira vers pipe_out
        
        // Fermer les descripteurs inutiles
        close(pipe_in[0]); close(pipe_in[1]);
        close(pipe_out[0]); close(pipe_out[1]);
        
        // CRUCIAL : Définir les variables d'environnement CGI
        setenv("REQUEST_METHOD", request.method.c_str(), 1);
        
        if (!request.query_string.empty())
            setenv("QUERY_STRING", request.query_string.c_str(), 1);
        else
            setenv("QUERY_STRING", "", 1);
        
        if (request.method == "POST")
        {
            std::ostringstream oss;
            oss << request.body.length();
            setenv("CONTENT_LENGTH", oss.str().c_str(), 1);
            
            std::map<std::string, std::string>::const_iterator it;
            it = request.headers.find("content-type");
            if (it != request.headers.end())
                setenv("CONTENT_TYPE", it->second.c_str(), 1);
            else
                setenv("CONTENT_TYPE", "application/x-www-form-urlencoded", 1);
        }
        else
        {
            setenv("CONTENT_LENGTH", "0", 1);
        }
        
       setenv("SCRIPT_NAME", script_path.c_str(), 1);
setenv("SERVER_NAME", _config.server_name.c_str(), 1);

std::ostringstream port_oss;
port_oss << _config.listen;
setenv("SERVER_PORT", port_oss.str().c_str(), 1);

setenv("SERVER_PROTOCOL", "HTTP/1.1", 1);
setenv("GATEWAY_INTERFACE", "CGI/1.1", 1);

// Ajouter tous les headers HTTP comme HTTP_*
std::map<std::string, std::string>::const_iterator it;
for (it = request.headers.begin(); it != request.headers.end(); ++it)
{
    std::string env_name = "HTTP_" + ft_to_upper_env(it->first);
    setenv(env_name.c_str(), it->second.c_str(), 1);
}

// NOUVEAU : Gestion correcte des chemins
chdir("./www");

// Calculer le nom du script relatif au dossier www
std::string script_name;
if (script_path.find("./www/") == 0)
{
    script_name = script_path.substr(6); // Enlever "./www/"
}
else
{
    script_name = script_path;
}

// Exécuter le script Python
char* args[] = {(char*)"python3", (char*)script_name.c_str(), NULL};
execve("/usr/bin/python3", args, environ);
        
        // Si on arrive ici, execve a échoué
        exit(1);
    }
    else // Processus parent = ton serveur
    {
        // Fermer les côtés inutiles des pipes
        close(pipe_in[0]);
        close(pipe_out[1]);
        
        // Si c'est POST, envoyer le body au script via stdin
        if (request.method == "POST" && !request.body.empty())
        {
            write(pipe_in[1], request.body.c_str(), request.body.length());
        }
        close(pipe_in[1]); // Fermer stdin (EOF pour le script)
        
        // Lire la réponse du script depuis stdout
        std::string cgi_output;
        char buffer[1024];
        ssize_t bytes_read;
        
        while ((bytes_read = read(pipe_out[0], buffer, sizeof(buffer) - 1)) > 0)
        {
            buffer[bytes_read] = '\0';
            cgi_output += buffer;
        }
        close(pipe_out[0]);
        
        // Attendre que le processus enfant se termine
        int status;
        waitpid(pid, &status, 0);
        
        // Vérifier si le script s'est terminé correctement
        if (WEXITSTATUS(status) != 0)
            return ft_build_500_response();
        
        // Parser la sortie CGI et construire la réponse HTTP
        return ft_build_cgi_response(cgi_output);
    }
    
    return ft_build_500_response(); // Ne devrait jamais arriver
}

std::string Server::ft_build_cgi_response(const std::string& cgi_output)
{
    // Le script CGI renvoie : headers + ligne vide + body
    size_t separator = cgi_output.find("\n\n");
    if (separator == std::string::npos)
        separator = cgi_output.find("\r\n\r\n");
    
    if (separator == std::string::npos)
        return ft_build_500_response();
    
    std::string cgi_headers = cgi_output.substr(0, separator);
    std::string cgi_body = cgi_output.substr(separator + 2);
    
    // Construire la réponse HTTP complète
    std::ostringstream oss;
    oss << cgi_body.length();
    
    std::string response = "HTTP/1.1 200 OK\r\n";
    response += cgi_headers + "\r\n"; // Headers du script
    response += "Content-Length: " + oss.str() + "\r\n";
    response += "Server: WebServ/1.0\r\n";
    response += "Connection: close\r\n";
    response += "\r\n";
    response += cgi_body;
    
    return response;
}

// Fonction helper pour convertir les noms de headers
std::string Server::ft_to_upper_env(const std::string& str)
{
    std::string result = str;
    size_t i = 0;
    while (i < result.length())
    {
        if (result[i] == '-')
            result[i] = '_';
        else
            result[i] = std::toupper(result[i]);
        i++;
    }
    return result;
}

std::string Server::ft_build_404_response(void)
{
	// 1. Créer le body HTML de la page d'erreur 404
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>404 Not Found</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>404 - Page Not Found</h1>\n<p>The requested file was not found.</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	// 2. Calculer la taille du body
	std::ostringstream oss;
	oss << body.length();
	
	// 3. Construire la réponse HTTP 404
	std::string response = "HTTP/1.1 404 Not Found\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}

std::string Server::ft_build_403_response(void)
{
	// 1. Créer le body HTML de la page d'erreur 403
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>403 Forbidden</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>403 - Forbidden</h1>\n<p>Access denied.</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	// 2. Calculer la taille du body
	std::ostringstream oss;
	oss << body.length();
	
	// 3. Construire la réponse HTTP 403
	std::string response = "HTTP/1.1 403 Forbidden\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}

// NOUVELLES MÉTHODES pour les erreurs de parsing HTTP

std::string Server::ft_build_400_response(void)
{
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>400 Bad Request</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>400 - Bad Request</h1>\n<p>The request could not be understood.</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 400 Bad Request\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}

std::string Server::ft_build_405_response(void)
{
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>405 Method Not Allowed</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>405 - Method Not Allowed</h1>\n<p>The method is not allowed.</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 405 Method Not Allowed\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}

std::string Server::ft_build_413_response(void)
{
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>413 Payload Too Large</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>413 - Payload Too Large</h1>\n<p>The request body is too large.</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 413 Payload Too Large\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}
#include "../../includes/Server.hpp"
#include <sstream>
#include <ctime>

// Parser les données POST (application/x-www-form-urlencoded)
std::map<std::string, std::string> Server::ft_parse_post_data(const std::string& body)
{
	std::map<std::string, std::string> params;
	
	if (body.empty())
		return params;
	
	// Exemple de body : "username=john&password=secret&email=john@test.com"
	std::string current_body = body;
	
	// Parcourir les paramètres séparés par '&'
	size_t amp_pos = 0;
	while (amp_pos != std::string::npos)
	{
		// Trouver le prochain '&' ou la fin
		size_t next_amp = current_body.find('&', amp_pos);
		
		// Extraire une paire key=value
		std::string pair;
		if (next_amp != std::string::npos)
		{
			pair = current_body.substr(amp_pos, next_amp - amp_pos);
			amp_pos = next_amp + 1;
		}
		else
		{
			pair = current_body.substr(amp_pos);
			amp_pos = std::string::npos;  // Dernière itération
		}
		
		// Séparer key=value
		size_t equal_pos = pair.find('=');
		if (equal_pos != std::string::npos)
		{
			std::string key = pair.substr(0, equal_pos);
			std::string value = pair.substr(equal_pos + 1);
			params[key] = value;
		}
	}
	
	return params;
}

// Gérer la connexion (login)
std::string Server::ft_handle_login(const std::map<std::string, std::string>& params)
{
	std::map<std::string, std::string>::const_iterator user_it = params.find("username");
	std::map<std::string, std::string>::const_iterator pass_it = params.find("password");
	
	if (user_it == params.end() || pass_it == params.end())
	{
		return ft_build_400_response();
	}
	
	std::string username = user_it->second;
	std::string password = pass_it->second;
	
	// Authentification avec les identifiants de tes pages HTML
	if (username == "hsorel" && password == "qwerty")
	{
		// Redirection vers dev.html (connexion réussie)
		return ft_build_redirect_response("/dev.html");
	}
	else
	{
		// Redirection vers invalidlogin.html (échec)
		return ft_build_redirect_response("/invalidlogin.html");
	}
}

// Gérer l'upload de fichiers
std::string Server::ft_handle_upload(const std::map<std::string, std::string>& params)
{
	std::map<std::string, std::string>::const_iterator file_it = params.find("filename");
	std::map<std::string, std::string>::const_iterator content_it = params.find("content");
	
	if (file_it == params.end())
	{
		return ft_build_post_success_response("Upload simulé - aucun fichier spécifié");
	}
	
	std::string filename = file_it->second;
	std::string content = (content_it != params.end()) ? content_it->second : "contenu vide";
	
	std::string success_msg = "Fichier '" + filename + "' uploadé avec succès (" + content + ")";
	return ft_build_post_success_response(success_msg);
}

// Gérer le formulaire de contact
std::string Server::ft_handle_contact(const std::map<std::string, std::string>& params)
{
	std::map<std::string, std::string>::const_iterator name_it = params.find("name");
	std::map<std::string, std::string>::const_iterator email_it = params.find("email");
	std::map<std::string, std::string>::const_iterator message_it = params.find("message");
	
	std::string name = (name_it != params.end()) ? name_it->second : "Anonyme";
	std::string email = (email_it != params.end()) ? email_it->second : "non spécifié";
	std::string message = (message_it != params.end()) ? message_it->second : "message vide";
	
	std::string response_msg = "Message reçu de " + name + " (" + email + "): " + message;
	return ft_build_post_success_response(response_msg);
}

// Construire une réponse de succès pour POST
std::string Server::ft_build_post_success_response(const std::string& message)
{
	// Créer le body HTML
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>Success</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>✓ Succès</h1>\n";
	body += "<p>" + message + "</p>\n";
	body += "<p><a href='/'>Retour à l'accueil</a></p>\n";
	body += "<hr>\n<p><em>WebServ/1.0 - " + ft_get_timestamp() + "</em></p>\n";
	body += "</body>\n</html>";
	
	// Calculer Content-Length
	std::ostringstream oss;
	oss << body.length();
	
	// Construire la réponse HTTP
	std::string response = "HTTP/1.1 200 OK\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n";
	response += "Server: WebServ/1.0\r\n";
	response += "Connection: close\r\n";
	response += "\r\n";
	response += body;
	
	return response;
}

// Construire une réponse 401 Unauthorized
std::string Server::ft_build_401_response(const std::string& content)
{
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>401 Unauthorized</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>401 - Non autorisé</h1>\n";
	body += "<p>" + content + "</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 401 Unauthorized\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}

// Construire une réponse 500 Internal Server Error
std::string Server::ft_build_500_response(void)
{
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>500 Internal Server Error</title></head>\n";
	body += "<body style='font-family: Arial; text-align: center; margin-top: 50px;'>\n";
	body += "<h1>500 - Erreur interne du serveur</h1>\n";
	body += "<p>Une erreur s'est produite lors du traitement de votre requête.</p>\n";
	body += "<hr>\n<p><em>WebServ/1.0</em></p>\n</body>\n</html>";
	
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 500 Internal Server Error\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n\r\n";
	response += body;
	
	return response;
}

// Construire une réponse de succès générique
std::string Server::ft_build_success_response(const std::string& content, const std::string& content_type)
{
	std::ostringstream oss;
	oss << content.length();
	
	std::string response = "HTTP/1.1 200 OK\r\n";
	response += "Content-Type: " + content_type + "\r\n";
	response += "Content-Length: " + oss.str() + "\r\n";
	response += "Server: WebServ/1.0\r\n";
	response += "Connection: close\r\n";
	response += "\r\n";
	response += content;
	
	return response;
}

// Obtenir un timestamp pour les logs
std::string Server::ft_get_timestamp(void)
{
	time_t raw_time;
	struct tm* time_info;
	char buffer[80];
	
	time(&raw_time);
	time_info = localtime(&raw_time);
	
	strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", time_info);
	return std::string(buffer);
}

// Construire une réponse de redirection HTTP 302
std::string Server::ft_build_redirect_response(const std::string& location)
{
	std::string body = "<!DOCTYPE html>\n<html>\n<head><title>Redirection</title></head>\n";
	body += "<body>\n<p>Redirection en cours vers <a href=\"" + location + "\">" + location + "</a></p>\n";
	body += "</body>\n</html>";
	
	std::ostringstream oss;
	oss << body.length();
	
	std::string response = "HTTP/1.1 302 Found\r\n";
	response += "Location: " + location + "\r\n";
	response += "Content-Type: text/html\r\n";
	response += "Content-Length: " + oss.str() + "\r\n";
	response += "Server: WebServ/1.0\r\n";
	response += "Connection: close\r\n";
	response += "\r\n";
	response += body;
	
	return response;
}
#include "../../includes/Server.hpp"
#include "../../includes/HttpRequest.hpp"
#include <sstream>

// Fonctions de parsing HTTP externes
HttpRequest ft_parse_http_request(const std::string& raw_data);
bool ft_is_request_complete(const std::string& data);

void Server::ft_accept_new_client(void)
{
	// 1. Préparer la structure pour l'adresse du client
	struct sockaddr_in client_addr;
	socklen_t client_len = sizeof(client_addr);

	// 2. Accepter la connexion
	int client_fd = accept(_server_fd, (struct sockaddr*)&client_addr, &client_len);
	if (client_fd < 0)
	{
		// Pas d'erreur grave, juste pas de client maintenant
		return;
	}

	// 3. Rendre le socket client non-bloquant aussi
	if (fcntl(client_fd, F_SETFL, O_NONBLOCK) < 0)
	{
		close(client_fd);  // Fermer si on peut pas configurer
		return;
	}

	// 4. Ajouter le nouveau client à notre surveillance
	FD_SET(client_fd, &_master_fds);
	_client_fds.push_back(client_fd);
	
	// 5. Mettre à jour le max_fd si nécessaire
	if (client_fd > _max_fd)
		_max_fd = client_fd;

	std::cout << "New client connected: " << client_fd << std::endl;
}

std::string Server::ft_handle_delete(const std::string& uri) {
    // 1. Convertir l'URI en chemin local (à adapter selon ton root)
    std::string path = "./" + uri;

    // 2. Vérifier si le fichier existe
    struct stat st;
    if (stat(path.c_str(), &st) != 0) {
        // Fichier inexistant
        return "HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\n\r\n";
    }

    // 3. Vérifier que c'est un fichier (pas un dossier)
    if (S_ISDIR(st.st_mode)) {
        return "HTTP/1.1 403 Forbidden\r\nContent-Length: 0\r\n\r\n";
    }

    // 4. Essayer de supprimer le fichier
    if (remove(path.c_str()) == 0) {
        // Succès
        return "HTTP/1.1 204 No Content\r\nContent-Length: 0\r\n\r\n";
    } else {
        // Erreur système (permissions, etc.)
        std::ostringstream oss;
        oss << "HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\n";
        oss << "Content-Length: " << strlen(strerror(errno)) << "\r\n\r\n";
        oss << strerror(errno);
        return oss.str();
    }
}

void Server::ft_handle_client_request(int client_fd)
{
	// 1. Buffer pour recevoir les données
	char buffer[BUFFER_SIZE];
	ssize_t bytes_read = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
	
	// 2. Vérifier si le client s'est déconnecté
	if (bytes_read <= 0)
	{
		// Client déconnecté ou erreur
		ft_disconnect_client(client_fd);
		return;
	}

	// 3. Terminer la chaîne reçue
	buffer[bytes_read] = '\0';
	std::string raw_data(buffer);
	
	std::cout << "Raw data received (" << bytes_read << " bytes)" << std::endl;
	
	// 4. Vérifier si la requête est complète
	if (!ft_is_request_complete(raw_data))
	{
		std::cout << "Incomplete request, waiting for more data..." << std::endl;
		return;
	}
	
	std::cout << "Complete request received, parsing..." << std::endl;
	
	// 5. Parser la requête HTTP complète
	HttpRequest request = ft_parse_http_request(raw_data);
	
	// 6. Vérifier si le parsing a réussi
	if (!request.is_valid)
	{
		std::cout << "Parse error: " << request.error_message << std::endl;
		std::string error_response = ft_build_400_response();
		send(client_fd, error_response.c_str(), error_response.length(), 0);
		ft_disconnect_client(client_fd);
		return;
	}
	
	// 7. Afficher les infos de la requête parsée
	std::cout << "✓ Request parsed successfully:" << std::endl;
	std::cout << "  Method: " << request.method << std::endl;
	std::cout << "  URI: " << request.uri << std::endl;
	std::cout << "  Version: " << request.version << std::endl;
	std::cout << "  Headers: " << request.headers.size() << " header(s)" << std::endl;
	
	// 8. NOUVEAU : Utiliser la configuration pour traiter la requête avec le body
	std::string response = ft_handle_request_with_config(request.method, request.uri, request.body);
	
	// 9. Envoyer la réponse au client
	send(client_fd, response.c_str(), response.length(), 0);
	
	// 10. Fermer la connexion
	ft_disconnect_client(client_fd);
}

void Server::ft_disconnect_client(int client_fd)
{
	std::cout << "Client disconnected: " << client_fd << std::endl;
	
	// Fermer le socket
	close(client_fd);
	
	// Retirer de la surveillance select()
	FD_CLR(client_fd, &_master_fds);
	
	// Retirer de notre liste de clients
	size_t i = 0;
	while (i < _client_fds.size())
	{
		if (_client_fds[i] == client_fd)
		{
			_client_fds.erase(_client_fds.begin() + i);
			break;
		}
		i++;
	}
}
#include "../../includes/Server.hpp"
#include <iostream>
#include <cstdlib>
#include "../../includes/ServerConfig.hpp"

void ft_print_config(const ServerConfig& config)
{
    std::cout << "=== Configuration du serveur ===" << std::endl;
    std::cout << "Port: " << config.listen << std::endl;
    std::cout << "Server name: " << config.server_name << std::endl;
    std::cout << "Root: " << config.root << std::endl;
    std::cout << "Index: " << config.index << std::endl;
    
    std::cout << "Méthodes autorisées: ";
    size_t i = 0;
    while (i < config.allowed_methods.size())
    {
        std::cout << config.allowed_methods[i];
        if (i < config.allowed_methods.size() - 1)
            std::cout << ", ";
        i++;
    }
    std::cout << std::endl;

    std::cout << std::endl << "=== Locations configurées ===" << std::endl;
    i = 0;
    while (i < config.locations.size())
    {
        const LocationConfig& loc = config.locations[i];
        std::cout << "📍 Location [" << i + 1 << "]: " << loc.path << std::endl;
        std::cout << "   Root: " << (loc.root.empty() ? "(défaut serveur)" : loc.root) << std::endl;
        std::cout << "   Index: " << (loc.index.empty() ? "(défaut serveur)" : loc.index) << std::endl;
        std::cout << "   Taille max body: " << loc.client_max_body_size << " bytes" << std::endl;
        
        std::cout << "   Méthodes: ";
        if (loc.allowed_methods.empty())
        {
            std::cout << "(défaut serveur)";
        }
        else
        {
            size_t j = 0;
            while (j < loc.allowed_methods.size())
            {
                std::cout << loc.allowed_methods[j];
                if (j < loc.allowed_methods.size() - 1)
                    std::cout << ", ";
                j++;
            }
        }
        std::cout << std::endl << std::endl;
        i++;
    }
}

int main(int ac, char** av)
{
    // Vérifier les arguments
    if (ac != 2)
    {
        std::cerr << "❌ Usage: " << av[0] << " <config_file>" << std::endl;
        std::cerr << "   Exemple: " << av[0] << " config/config.conf" << std::endl;
        return 1;
    }

    try
    {
        std::cout << "🔧 Chargement de la configuration..." << std::endl;
        
        // Parser la configuration
        ServerConfig config = parseConfigFile(av[1]);
        
        std::cout << "✅ Configuration chargée avec succès !" << std::endl << std::endl;
        
        // Afficher la configuration
        ft_print_config(config);
        
        std::cout << "🚀 Démarrage de WebServ..." << std::endl;
        
        // Créer le serveur avec la config
        Server server(config);
        
        // Initialiser et démarrer
        server.ft_init_server();
        server.ft_start_listening();
        
        std::cout << "🌐 Serveur prêt ! Accès: http://" << config.server_name << ":" << config.listen << std::endl;
        std::cout << "📝 Pages disponibles:" << std::endl;
        std::cout << "   • http://localhost:" << config.listen << "/" << std::endl;
        std::cout << "   • http://localhost:" << config.listen << "/login.html" << std::endl;
        std::cout << "   • http://localhost:" << config.listen << "/about.html" << std::endl;
        std::cout << "   • http://localhost:" << config.listen << "/dev.html" << std::endl;
        std::cout << "   • http://localhost:" << config.listen << "/invalidlogin.html" << std::endl;
        std::cout << "   • http://localhost:" << config.listen << "/cgi-bin/time.py" << std::endl;
        std::cout << std::endl << "🔧 Endpoints POST:" << std::endl;
        std::cout << "   • POST /login (authentification)" << std::endl;
        std::cout << "   • POST /upload (upload de fichiers)" << std::endl;
        std::cout << "   • POST /contact (formulaire de contact)" << std::endl;
        std::cout << std::endl << "🔄 En attente de connexions..." << std::endl;
        
        // Boucle principale
        server.ft_handle_connections();
    }
    catch (const std::exception& e)
    {
        std::cerr << "❌ Erreur: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Parser.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 11:36:48 by mwattier          #+#    #+#             */
/*   Updated: 2025/06/24 13:32:29 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/ServerConfig.hpp"

// Fonction helper pour trimmer les espaces et enlever les ';'
std::string ft_trim_line(const std::string& line)
{
    size_t start = 0;
    size_t end = line.length();
    
    // Trouver le premier caractère non-espace
    while (start < line.length() && std::isspace(line[start]))
        start++;
    
    // Trouver le dernier caractère non-espace/non-;
    while (end > start && (std::isspace(line[end - 1]) || line[end - 1] == ';'))
        end--;
    
    return line.substr(start, end - start);
}

void parseDirective(const std::string& line, ServerConfig& config) {
    std::string trimmed = ft_trim_line(line);
    std::istringstream iss(trimmed);
    std::string key;
    iss >> key;
    
    if (key == "listen") {
        iss >> config.listen;
    } else if (key == "server_name") {
        iss >> config.server_name;
    } else if (key == "root") {
        iss >> config.root;
    } else if (key == "index") {
        iss >> config.index;
    } else if (key == "allowed_methods") {
        std::string method;
        while (iss >> method) {
            config.allowed_methods.push_back(method);
        }
    }
}

void parseLocation(std::ifstream& file, ServerConfig& config, const std::string& location_line) {
    LocationConfig loc;
    
    // Parser la ligne location pour extraire le path
    std::istringstream iss(location_line);
    std::string location_keyword, path;
    iss >> location_keyword >> path;
    loc.path = path;
    
    // Initialiser avec des valeurs par défaut
    loc.client_max_body_size = 1000000;  // 1MB par défaut
    
    std::string line;
    // Lire les directives du bloc location
    while (std::getline(file, line)) {
        line = ft_trim_line(line);
        if (line.empty()) continue;
        if (line == "}") break; // Fin du bloc
        
        std::istringstream iss(line);
        std::string key;
        iss >> key;
        
        if (key == "root") {
            iss >> loc.root;
        } else if (key == "index") {
            iss >> loc.index;
        } else if (key == "allowed_methods") {
            std::string method;
            while (iss >> method) {
                loc.allowed_methods.push_back(method);
            }
        } else if (key == "client_max_body_size") {
            iss >> loc.client_max_body_size;
        }
    }
    config.locations.push_back(loc);
}

ServerConfig parseConfigFile(const std::string& filename) {
    std::ifstream file(filename.c_str());
    ServerConfig config;
    std::string line;

    if (!file.is_open()) {
        throw std::runtime_error("Cannot open config file: " + filename);
    }

    // Valeurs par défaut
    config.listen = 8080;
    config.server_name = "localhost";
    config.root = "./www";
    config.index = "index.html";

    bool in_server_block = false;

    while (std::getline(file, line)) {
        line = ft_trim_line(line);
        
        if (line.empty() || line[0] == '#') continue;

        if (line.find("server") == 0 && line.find("{") != std::string::npos) {
            in_server_block = true;
            continue;
        }
        
        if (line == "}" && in_server_block) {
            in_server_block = false;
            continue;
        }
        
        if (!in_server_block) continue;

        if (line.find("location") == 0) {
            parseLocation(file, config, line);
        } else {
            parseDirective(line, config);
        }
    } 
    file.close();
    return config;
}#ifndef HTTP_REQUEST_HPP
# define HTTP_REQUEST_HPP

# include <string>
# include <map>
# include <vector>
# include <cstdlib>
// Structure pour stocker une requête HTTP parsée
struct HttpRequest
{
	// Request line
	std::string method;        // GET, POST, DELETE
	std::string uri;           // /path/to/resource (sans query string)
	std::string query_string;  // param1=value1&param2=value2
	std::string version;       // HTTP/1.1
	
	// Headers HTTP (clés en minuscules)
	std::map<std::string, std::string> headers;
	
	// Body de la requête (pour POST)
	std::string body;
	
	// État du parsing
	bool is_valid;             // Requête bien parsée ?
	bool is_complete;          // Requête complètement reçue ?
	int error_code;            // Code d'erreur HTTP si problème
	std::string error_message; // Message d'erreur détaillé
	
	// Constructeur par défaut
	HttpRequest(void) : is_valid(false), is_complete(false), error_code(400) {}
};

// Déclarations des fonctions de parsing
bool ft_parse_request_line(const std::string& line, HttpRequest& request);
bool ft_parse_headers(const std::string& headers_block, HttpRequest& request);
HttpRequest ft_parse_http_request(const std::string& raw_data);
bool ft_is_request_complete(const std::string& data);

// Codes d'erreur HTTP courants
# define HTTP_OK 200
# define HTTP_BAD_REQUEST 400
# define HTTP_NOT_FOUND 404
# define HTTP_METHOD_NOT_ALLOWED 405
# define HTTP_LENGTH_REQUIRED 411
# define HTTP_PAYLOAD_TOO_LARGE 413
# define HTTP_URI_TOO_LONG 414
# define HTTP_VERSION_NOT_SUPPORTED 505

// Limites de sécurité
# define MAX_URI_LENGTH 2048
# define MAX_HEADER_SIZE 8192
# define MAX_HEADERS_COUNT 100
# define MAX_REQUEST_SIZE 1048576  // 1MB

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerConfig.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/12 11:35:25 by mwattier          #+#    #+#             */
/*   Updated: 2025/06/24 11:39:41 by jmaizel          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVER_CONFIG_HPP
# define SERVER_CONFIG_HPP

#include <string>
#include <vector>
#include <map>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <cstdlib>

struct LocationConfig {
    std::string path;
    std::string root;
    std::string index;
    std::vector<std::string> allowed_methods;
    int client_max_body_size;
};

struct ServerConfig {
    int listen;
    std::string server_name;
    std::string root;
    std::string index;
    std::vector<std::string> allowed_methods;
    std::vector<LocationConfig> locations;
    std::map<int, std::string> error_pages;
};

ServerConfig parseConfigFile(const std::string& filename);

#endif#ifndef SERVER_HPP
# define SERVER_HPP

# include <sys/socket.h>
# include <netinet/in.h>
# include <arpa/inet.h>
# include <sys/select.h>
# include <sys/wait.h>        // Pour waitpid
# include <unistd.h>
# include <fcntl.h>
# include <iostream>
# include <vector>
# include <map>
# include <string>
# include <stdexcept>
# include <sstream>
# include <cstdio>
# include <fstream>
# include <cstdlib>
# include "ServerConfig.hpp"
# include "HttpRequest.hpp"   // ← AJOUTE CETTE LIGNE
# include <sys/stat.h>
# include <cerrno>
# include <cstring>

# define MAX_CLIENTS 1024
# define BUFFER_SIZE 4096

class Server
{
	private:
		int					_server_fd;
		struct sockaddr_in	_address;
		fd_set				_read_fds;
		fd_set				_write_fds;
		fd_set				_master_fds;
		int					_max_fd;
		std::vector<int>	_client_fds;
		ServerConfig		_config;  // NOUVEAU : Stocker la configuration

	public:
		// Classe canonique
		Server(void);
		Server(const ServerConfig& config);  // NOUVEAU : Constructeur avec config
		Server(const Server& other);
		~Server(void);
		Server& operator=(const Server& other);

		// Methodes principales (Server.cpp)
		void			ft_init_server(void);
		void			ft_start_listening(void);
		void			ft_handle_connections(void);
		
		// Methodes réseau (ServerNetwork.cpp)
		void			ft_accept_new_client(void);
		void			ft_handle_client_request(int client_fd);
		void			ft_disconnect_client(int client_fd);
		
		// Methodes HTTP (ServerHttp.cpp)
		std::string 	ft_handle_delete(const std::string& uri);
		std::string		ft_handle_request_simple(const std::string& uri);  // Ancienne méthode
		std::string		ft_handle_request_with_config(const std::string& method, const std::string& uri, const std::string& body);  // NOUVEAU
		
		// CGI - Deux versions pour compatibilité
		std::string		ft_execute_cgi(const std::string& script_path, const HttpRequest& request);  // Nouvelle version
		std::string		ft_build_cgi_response(const std::string& cgi_output);
		std::string		ft_to_upper_env(const std::string& str);
		
		// Réponses d'erreur
		std::string		ft_build_404_response(void);
		std::string		ft_build_403_response(void);
		std::string		ft_build_400_response(void);
		std::string		ft_build_405_response(void);
		std::string		ft_build_413_response(void);  // NOUVEAU : Payload Too Large
		
		// Methodes POST (NOUVEAU)
		std::string		ft_handle_post_request_with_config(const std::string& uri, const std::string& body);
		std::map<std::string, std::string>	ft_parse_post_data(const std::string& body);
		std::string		ft_handle_login(const std::map<std::string, std::string>& params);
		std::string		ft_handle_upload(const std::map<std::string, std::string>& params);
		std::string		ft_handle_contact(const std::map<std::string, std::string>& params);
		std::string		ft_get_timestamp(void);
		std::string		ft_build_success_response(const std::string& content, const std::string& content_type);
		std::string		ft_build_401_response(const std::string& content);
		std::string		ft_build_500_response(void);
		std::string		ft_build_post_success_response(const std::string& message);
		
		// Methodes fichiers (ServerFiles.cpp)
		std::string		ft_read_file_simple(const std::string& file_path);
		std::string		ft_get_content_type(const std::string& file_path);
		std::string		ft_serve_static_file(const std::string& uri);  // Ancienne méthode
		std::string		ft_serve_static_file_with_config(const std::string& uri);  // NOUVEAU
		
		// Methodes configuration (ServerConfigMethods.cpp) - NOUVEAU
		const LocationConfig*	ft_find_location(const std::string& uri);
		bool					ft_is_method_allowed(const std::string& method, const LocationConfig* location);
		std::string				ft_get_file_path(const std::string& uri, const LocationConfig* location);
		std::string				ft_build_redirect_response(const std::string& location);
		
		// Helper pour CGI
		std::string		ft_get_directory_path(const std::string& file_path);
};

#endif#include "HttpRequest.hpp"
#include <sstream>
#include <iostream>
#include <cctype>

// Fonction pour trimmer les espaces
std::string ft_trim_header(const std::string& str)
{
    if (str.empty())
        return str;
    
    size_t start = 0;
    size_t end = str.length();
    
    // Trouver le premier caractère non-espace
    while (start < str.length() && std::isspace(str[start]))
        start++;
    
    // Trouver le dernier caractère non-espace
    while (end > start && std::isspace(str[end - 1]))
        end--;
    
    return str.substr(start, end - start);
}

// Convertir en minuscules
std::string ft_to_lower_header(const std::string& str)
{
    std::string result = str;
    size_t i = 0;
    while (i < result.length())
    {
        result[i] = std::tolower(result[i]);
        i++;
    }
    return result;
}

// Parser les headers HTTP
bool ft_parse_headers(const std::string& headers_block, HttpRequest& request)
{
    if (headers_block.empty())
        return true;  // Pas de headers, c'est ok
    
    std::istringstream stream(headers_block);
    std::string line;
    
    while (std::getline(stream, line))
    {
        // Enlever \r en fin de ligne si présent
        if (!line.empty() && line[line.length() - 1] == '\r')
            line.erase(line.length() - 1);
        
        // Ligne vide = fin des headers
        if (line.empty())
            break;
        
        // Trouver le séparateur ':'
        size_t colon_pos = line.find(':');
        if (colon_pos == std::string::npos)
        {
            request.error_message = "Malformed header: " + line;
            return false;
        }
        
        // Extraire key et value
        std::string key = line.substr(0, colon_pos);
        std::string value = line.substr(colon_pos + 1);
        
        // Nettoyer les espaces
        key = ft_trim_header(key);
        value = ft_trim_header(value);
        
        // Vérifier que la clé n'est pas vide
        if (key.empty())
        {
            request.error_message = "Empty header key";
            return false;
        }
        
        // Convertir la clé en minuscules pour uniformité
        key = ft_to_lower_header(key);
        
        // Stocker le header
        request.headers[key] = value;
    }
    
    return true;
}#include "HttpRequest.hpp"
#include <cctype>

// Fonction principale pour parser une requête HTTP complète
HttpRequest ft_parse_http_request(const std::string& raw_data)
{
    HttpRequest request;
    
    // 1. Vérifier que la requête semble complète (contient \r\n\r\n)
    size_t headers_end = raw_data.find("\r\n\r\n");
    if (headers_end == std::string::npos)
    {
        request.error_message = "Incomplete request (missing \\r\\n\\r\\n)";
        return request;
    }
    
    // 2. Séparer la partie headers de la partie body
    std::string headers_part = raw_data.substr(0, headers_end);
    std::string body_part = raw_data.substr(headers_end + 4);  // Skip "\r\n\r\n"
    
    // 3. Extraire la première ligne (request line)
    size_t first_line_end = headers_part.find("\r\n");
    if (first_line_end == std::string::npos)
    {
        request.error_message = "No request line found";
        return request;
    }
    
    std::string request_line = headers_part.substr(0, first_line_end);
    std::string headers_block = headers_part.substr(first_line_end + 2);  // Skip "\r\n"
    
    // 4. Parser la request line
    if (!ft_parse_request_line(request_line, request))
        return request;  // Erreur déjà définie dans la fonction
    
    // 5. Parser les headers
    if (!ft_parse_headers(headers_block, request))
        return request;  // Erreur déjà définie dans la fonction
    
    // 6. Pour POST, récupérer le body si Content-Length existe
    if (request.method == "POST")
    {
        std::map<std::string, std::string>::iterator it = request.headers.find("content-length");
        if (it != request.headers.end())
        {
            int content_length = std::atoi(it->second.c_str());
            if (content_length > 0 && content_length <= static_cast<int>(body_part.length()))
            {
                request.body = body_part.substr(0, content_length);
            }
        }
    }
    
    // 7. Tout est OK !
    request.is_valid = true;
    return request;
}

// Fonction helper pour vérifier si une requête est complète
bool ft_is_request_complete(const std::string& data)
{
    // Vérifier la présence de \r\n\r\n (fin des headers)
    size_t headers_end = data.find("\r\n\r\n");
    if (headers_end == std::string::npos)
        return false;
    
    // Pour GET/DELETE, c'est suffisant
    if (data.find("GET ") == 0 || data.find("DELETE ") == 0)
        return true;
    
    // Pour POST, vérifier qu'on a tout le body selon Content-Length
    if (data.find("POST ") == 0)
    {
        // Chercher Content-Length dans les headers
        size_t cl_pos = data.find("content-length:");
        if (cl_pos == std::string::npos)
            cl_pos = data.find("Content-Length:");
        
        if (cl_pos != std::string::npos && cl_pos < headers_end)
        {
            // Extraire la valeur de Content-Length
            size_t line_end = data.find("\r\n", cl_pos);
            if (line_end != std::string::npos)
            {
                std::string cl_line = data.substr(cl_pos, line_end - cl_pos);
                size_t colon_pos = cl_line.find(':');
                if (colon_pos != std::string::npos)
                {
                    std::string cl_value = cl_line.substr(colon_pos + 1);
                    
                    // Enlever les espaces
                    size_t start = 0;
                    while (start < cl_value.length() && std::isspace(cl_value[start]))
                        start++;
                    cl_value = cl_value.substr(start);
                    
                    int content_length = std::atoi(cl_value.c_str());
                    int body_received = data.length() - (headers_end + 4);
                    
                    return body_received >= content_length;
                }
            }
        }
        return false;  // POST sans Content-Length valide
    }
    
    return true;  // Méthode inconnue, on suppose que c'est complet
}#include "HttpRequest.hpp"
#include <sstream>
#include <iostream>

// Parser la première ligne d'une requête HTTP
// Format : "GET /path HTTP/1.1"
bool ft_parse_request_line(const std::string& line, HttpRequest& request)
{
	if (line.empty())
	{
		request.error_message = "Empty request line";
		return false;
	}
	
	// Utiliser istringstream pour séparer les mots
	std::istringstream iss(line);
	std::string method, uri_with_query, version;
	
	// Extraire les 3 parties
	if (!(iss >> method >> uri_with_query >> version))
	{
		request.error_message = "Malformed request line";
		return false;
	}
	
	// Vérifications basiques
	if (method != "GET" && method != "POST" && method != "DELETE")
	{
		request.error_message = "Method not supported: " + method;
		return false;
	}
	
	if (version != "HTTP/1.1")
	{
		request.error_message = "Version not supported: " + version;
		return false;
	}
	
	if (uri_with_query.empty() || uri_with_query[0] != '/')
	{
		request.error_message = "Invalid URI: " + uri_with_query;
		return false;
	}
	
	// NOUVEAU : Séparer l'URI de la query string
	size_t query_pos = uri_with_query.find('?');
	if (query_pos != std::string::npos)
	{
		// Il y a une query string
		request.uri = uri_with_query.substr(0, query_pos);
		request.query_string = uri_with_query.substr(query_pos + 1);
	}
	else
	{
		// Pas de query string
		request.uri = uri_with_query;
		request.query_string = "";
	}
	
	// Stocker les autres valeurs
	request.method = method;
	request.version = version;
	
	return true;
}# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: jmaizel <jmaizel@student.42.fr>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/06/19 00:00:00 by jmaizel           #+#    #+#              #
#    Updated: 2025/06/26 14:39:17 by jmaizel          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# Nom de l'exécutable
NAME = webserv

# Compilateur et flags (respecter la Norme 42)
CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

# Dossiers
SRCDIR = srcs
OBJDIR = objs
INCDIR = includes

# Fichiers sources organisés par dossier
MAIN_SRCS = main/main.cpp

SERVER_SRCS = server/Server.cpp \
              server/ServerNetwork.cpp \
              server/ServerHttp.cpp \
              server/ServerFiles.cpp \
              server/ServerConfigMethods.cpp \
              server/ServerHttpPost.cpp

CONFIG_SRCS = parsing/Parser.cpp

HTTP_SRCS = http/HttpRequestLine.cpp \
            http/HttpHeaders.cpp \
            http/HttpParser.cpp

# Tous les fichiers sources
SRCS = $(MAIN_SRCS) $(SERVER_SRCS) $(CONFIG_SRCS) $(HTTP_SRCS)

# Ajouter le préfixe du dossier source
SRCS_FULL = $(addprefix $(SRCDIR)/, $(SRCS))

# Fichiers objets (même structure dans objs/)
OBJS = $(SRCS_FULL:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)

# Flags d'inclusion
INCLUDES = -I$(INCDIR)

# Couleurs pour l'affichage
GREEN = \033[0;32m
RED = \033[0;31m
YELLOW = \033[0;33m
BLUE = \033[0;34m
NC = \033[0m # No Color

# Règle principale
all: $(NAME)

# Création de l'exécutable
$(NAME): $(OBJS)
	@echo "$(YELLOW)Linking $(NAME)...$(NC)"
	@$(CXX) $(CXXFLAGS) $(OBJS) -o $(NAME)
	@echo "$(GREEN)✓ $(NAME) created successfully!$(NC)"
	@echo "$(BLUE)Usage: ./$(NAME) config.conf$(NC)"

# Règle pour compiler les fichiers .cpp en .o
$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
	@mkdir -p $(dir $@)
	@echo "$(YELLOW)Compiling $<...$(NC)"
	@$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@
	@echo "$(GREEN)✓ $@ created$(NC)"

# Nettoyage des fichiers objets
clean:
	@echo "$(RED)Cleaning object files...$(NC)"
	@rm -rf $(OBJDIR)
	@echo "$(GREEN)✓ Object files cleaned$(NC)"

# Nettoyage complet
fclean: clean
	@echo "$(RED)Cleaning executable...$(NC)"
	@rm -f $(NAME)
	@rm -f test_http test_headers
	@echo "$(GREEN)✓ Executable cleaned$(NC)"

# Recompilation complète
re: fclean all

# Test du parsing des headers HTTP
test_headers: $(OBJDIR)/http/HttpHeaders.o
	@echo "$(YELLOW)Creating test for HTTP headers...$(NC)"
	@echo '#include "HttpRequest.hpp"' > test_headers.cpp
	@echo '#include <iostream>' >> test_headers.cpp
	@echo 'bool ft_parse_headers(const std::string& headers_block, HttpRequest& request);' >> test_headers.cpp
	@echo 'int main() {' >> test_headers.cpp
	@echo '    std::string test = "Host: localhost:8080\\r\\nContent-Type: text/html\\r\\n";' >> test_headers.cpp
	@echo '    HttpRequest req;' >> test_headers.cpp
	@echo '    if (ft_parse_headers(test, req)) {' >> test_headers.cpp
	@echo '        std::cout << "✓ Headers parsed: " << req.headers.size() << " headers" << std::endl;' >> test_headers.cpp
	@echo '        std::map<std::string, std::string>::iterator it;' >> test_headers.cpp
	@echo '        for (it = req.headers.begin(); it != req.headers.end(); ++it)' >> test_headers.cpp
	@echo '            std::cout << "  " << it->first << ": " << it->second << std::endl;' >> test_headers.cpp
	@echo '    } else std::cout << "✗ Parse failed: " << req.error_message << std::endl;' >> test_headers.cpp
	@echo '    return 0;' >> test_headers.cpp
	@echo '}' >> test_headers.cpp
	@$(CXX) $(CXXFLAGS) $(INCLUDES) test_headers.cpp $(OBJDIR)/http/HttpHeaders.o -o test_headers
	@rm test_headers.cpp
	@echo "$(GREEN)✓ test_headers created! Run with: ./test_headers$(NC)"

# Test du parsing complet HTTP
test_http: $(OBJDIR)/http/HttpRequestLine.o $(OBJDIR)/http/HttpHeaders.o $(OBJDIR)/http/HttpParser.o
	@echo "$(YELLOW)Creating test for complete HTTP parsing...$(NC)"
	@echo '#include "HttpRequest.hpp"' > test_http.cpp
	@echo '#include <iostream>' >> test_http.cpp
	@echo 'HttpRequest ft_parse_http_request(const std::string& raw_data);' >> test_http.cpp
	@echo 'int main() {' >> test_http.cpp
	@echo '    std::string test = "GET /index.html HTTP/1.1\\r\\nHost: localhost:8080\\r\\nUser-Agent: curl/7.68.0\\r\\n\\r\\n";' >> test_http.cpp
	@echo '    HttpRequest req = ft_parse_http_request(test);' >> test_http.cpp
	@echo '    if (req.is_valid) {' >> test_http.cpp
	@echo '        std::cout << "✓ Complete parsing OK!" << std::endl;' >> test_http.cpp
	@echo '        std::cout << "Method: " << req.method << std::endl;' >> test_http.cpp
	@echo '        std::cout << "URI: " << req.uri << std::endl;' >> test_http.cpp
	@echo '        std::cout << "Headers: " << req.headers.size() << std::endl;' >> test_http.cpp
	@echo '    } else std::cout << "✗ Parse failed: " << req.error_message << std::endl;' >> test_http.cpp
	@echo '    return 0;' >> test_http.cpp
	@echo '}' >> test_http.cpp
	@$(CXX) $(CXXFLAGS) $(INCLUDES) test_http.cpp $(OBJDIR)/http/HttpRequestLine.o $(OBJDIR)/http/HttpHeaders.o $(OBJDIR)/http/HttpParser.o -o test_http
	@rm test_http.cpp
	@echo "$(GREEN)✓ test_http created! Run with: ./test_http$(NC)"

# Afficher les fichiers qui seront compilés
show:
	@echo "$(YELLOW)Source files:$(NC)"
	@echo "$(SRCS_FULL)" | tr ' ' '\n'
	@echo "$(YELLOW)Object files:$(NC)"
	@echo "$(OBJS)" | tr ' ' '\n"
	@echo "$(YELLOW)Include directories:$(NC)"
	@echo "$(INCDIR)"

# Test rapide de compilation
check: all
	@echo "$(BLUE)Testing compilation...$(NC)"
	@echo "$(GREEN)✓ All files compiled successfully!$(NC)"
	@echo "$(BLUE)Ready to run: ./$(NAME) config.conf$(NC)"

# Règles .PHONY
.PHONY: all clean fclean re test_http test_headers show check

# Dépendances des headers pour recompilation automatique
$(OBJDIR)/main/main.o: $(INCDIR)/Server.hpp $(INCDIR)/ServerConfig.hpp
$(OBJDIR)/server/Server.o: $(INCDIR)/Server.hpp
$(OBJDIR)/server/ServerNetwork.o: $(INCDIR)/Server.hpp $(INCDIR)/HttpRequest.hpp
$(OBJDIR)/server/ServerHttp.o: $(INCDIR)/Server.hpp
$(OBJDIR)/server/ServerFiles.o: $(INCDIR)/Server.hpp
$(OBJDIR)/parsing/Parser.o: $(INCDIR)/ServerConfig.hpp
$(OBJDIR)/http/HttpRequestLine.o: $(INCDIR)/HttpRequest.hpp
$(OBJDIR)/http/HttpHeaders.o: $(INCDIR)/HttpRequest.hpp
$(OBJDIR)/http/HttpParser.o: $(INCDIR)/HttpRequest.hpp