/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Config.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:39:59 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:40:00 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

LocationBloc::LocationBloc() :
    path("/"),
    root("www/"),
    allowed_methods(1, "GET"),
    client_max_body_size(1048576),
    index("index.html"),
    autoindex(false)
{

}

LocationBloc::~LocationBloc()
{

}

void    LocationBloc::print()
{
    std::cout << '\t' << path << "\n\t" << root << "\n\t" << client_max_body_size << "\n\t" << index << "\n\t" << autoindex << std::endl;
    for (size_t i = 0; i < allowed_methods.size(); i++)
        std::cout << "\t" << allowed_methods[i] << std::endl;
}

ServerBloc::ServerBloc() : 
    root(""),
    name("localhost"),
    index("index.html"),
    listen(-1),
    allowed_methods(1, "GET"),
    client_max_body_size(1048576),
    autoindex(false),
    locations()
{

}

ServerBloc::~ServerBloc()
{

}

void    ServerBloc::print()
{
    std::cout << listen << "\n" << name << "\n" << root << "\n" << index <<  "\n" << client_max_body_size << "\n" << autoindex << std::endl;;
    for (size_t i = 0; i < allowed_methods.size(); i++)
        std::cout << allowed_methods[i] << std::endl;
    for(std::map<std::string, LocationBloc>::iterator it = locations.begin(); it != locations.end(); ++it)
    {
        std::cout << "location : "<< it->first << std::endl;
        it->second.print();
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpRequest.cpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:41:00 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:41:01 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

/*  TEMPLATE

first line      GET /index.html HTTP/1.1\r\n
header          Host: localhost:8080\r\n
header          User-Agent: Mozilla/5.0 (X11; Linux x86_64)\r\n
header          Accept: text/html\r\n
header          Connection: keep-alive\r\n
\r\n
body(optional)  {"username":"harold","password":"42"}

*/

HttpRequest::HttpRequest() : _version(""), _headers(), _body("")
{

}

HttpRequest::HttpRequest(const HttpRequest &copy)
{

}

HttpRequest::~HttpRequest()
{

}

const std::string                         &HttpRequest::getMethod()const
{
    return (this->_method);
}

const std::string                         &HttpRequest::getTarget()const
{
    return (this->_target);
}

const std::string                         &HttpRequest::getVersion()const
{
    return (this->_version);
}

const std::map<std::string, std::string>    &HttpRequest::getHeaders()const
{
    return (this->_headers);
}

const std::string                         &HttpRequest::getBody()const
{
    return (this->_body);
}

const int   &HttpRequest::getFlag()const
{
    return (this->_flag);
}


void    HttpRequest::print()const
{
    std::map<std::string, std::string>::const_iterator it;

    std::cout << "=== HttpRequest ===" << std::endl;

    std::cout << this->_method << " " << this->_target << " " << this->_version << std::endl;

    for (it = this->_headers.begin(); it != this->_headers.end(); ++it)
        std::cout << it->first << ": " << it->second << std::endl;

    std::cout << this->_body << std::endl;

    std::cout << "====================" << std::endl;
}

//tokenizes based on /r/n. elements are seperated by spaces
std::vector<std::string> HttpRequest::tokenize(const std::string buffer)const
{
    std::string                 copy(buffer);
    std::string                 line;
    size_t                      pos;
    std::vector<std::string>    tokens;

    while ((pos = copy.find("\r\n")) != std::string::npos)
    {
        line = copy.substr(0, pos);
        if (!line.empty()) //if there is only "\r\n"
            tokens.push_back(line);
        tokens.push_back(" ");
        copy.erase(0, pos + 2);
    }
    //rest of the buffer
    if (!copy.empty())
        tokens.push_back(copy);
    return (tokens);
}


bool    HttpRequest::is_valid_request()const
{
    //ToDo
    return (true);
}

void    HttpRequest::parse(const std::string &buffer)
{
    std::vector<std::string>    tokens;
    std::vector<std::string>    elems;
    size_t                      pos;
    std::string                 key;
    std::string                 value;

    //check if there is a /r/n after the headers
    if (buffer.find("\r\n\r\n") == std::string::npos)
    {
        this->_flag = 400;
        return ;
    }
    tokens = tokenize(buffer);
    //check if it is not empty
    if (tokens.size() < 2)
    {
        this->_flag = 400;
        return ;
    }
    
    //split the first line
    elems = ft_split(tokens[0], " ");
    //check if there are 3 elements
    if (elems.size() < 3)
    {
        this->_flag = 400;
        return ;
    }
    this->_method = elems[0];
    this->_target = elems[1];
    this->_version = elems[2];

    //check the headers
    size_t i = 2;
    for (; i < tokens.size() ; ++i)
    {
        if (tokens[i] == " ")
        {
            if (i < tokens.size() - 1 && tokens[i + 1] == " ")
            {
                i += 2;
                break ;
            }
            continue ;
        }
        pos = (tokens[i]).find_first_of(":");
        if (pos == std::string::npos)
        {
            this->_flag = 400;
            return ;
        }
        key = (tokens[i]).substr(0, pos);
        value = (tokens[i]).substr(pos + 2);
        (this->_headers)[key] = value;
    }

    //check the body here it gets complicated so as of now just make it work
    //you have to check connexion and content length to validate the request

    //fill up the rest
    while (i < tokens.size())
    {
        this->_body += tokens[i];
        i++;
    }

    //check if valid
    if (!is_valid_request())
        this->_flag = 400;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpResponse.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:40:51 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:40:52 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

/*  TEMPLATE

first line  HTTP/1.1 200 OK\r\n
header      Content-Type: text/html\r\n
header      Content-Length: 32\r\n
header      Connection: close\r\n
\r\n
body        <html><h1>Hello World</h1></html>

*/

HttpResponse::HttpResponse() : _version(""), _headers(), _statusCode(0), _reason(""), _body("")
{

}

HttpResponse::HttpResponse(const HttpRequest &copy)
{

}

HttpResponse::~HttpResponse()
{

}



void    HttpResponse::setVersion(const std::string &version)
{
    this->_version = version;
}

void    HttpResponse::setStatusCode(int code)
{
    this->_statusCode = code;
}
void    HttpResponse::setReason(const std::string &reason)
{
    this->_reason = reason;
}

void    HttpResponse::setBody(const std::string &body)
{
    this->_body = body;
}

void    HttpResponse::setHeaders(const std::string &first, const std::string &second)
{
    this->_headers[first] = second;
}

void HttpResponse::print()
{
    std::cout << "=== HttpResponse ===" << std::endl;

    std::cout << this->_version << " " << this->_statusCode << " " << this->_reason << "\r\n";

    for (std::map<std::string, std::string>::const_iterator it = this->_headers.begin(); it != this->_headers.end(); ++it)
    {
        std::cout << it->first << ": " << it->second << "\r\n";
    }
    std::cout << "\r\n";

    std::cout << this->_body << std::endl;

    std::cout << "====================" << std::endl;
}


std::string HttpResponse::toStr()
{
    std::map<std::string, std::string>::iterator    it;
    std::ostringstream                              buffer;

    //first line
    buffer << this->_version << " " << this->_statusCode << " " << this->_reason << "\r\n";
    //headers
    for (it = this->_headers.begin(); it != this->_headers.end() ; ++it)
        buffer << it->first << ": " << it->second << "\r\n";
    //'\r\n' to finish off the headers
    buffer << "\r\n";
    //body
    buffer << this->_body;
    return (buffer.str());
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   CgiHandler.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:41:30 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/22 00:00:00 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

// Fonction pour vérifier si un fichier est un script CGI
bool ft_is_cgi_script(const std::string& file_path)
{
    size_t dot_pos = file_path.find_last_of('.');
    if (dot_pos == std::string::npos)
        return false;
        
    std::string ext = file_path.substr(dot_pos);
    return (ext == ".py" || ext == ".php" || ext == ".pl" || ext == ".sh");
}

// Fonction pour extraire la query string de l'URI
std::string ft_extract_query_string(const std::string& uri)
{
    size_t query_pos = uri.find('?');
    if (query_pos != std::string::npos)
        return uri.substr(query_pos + 1);
    return "";
}

// Fonction pour déterminer l'interpréteur selon l'extension
std::string ft_get_interpreter(const std::string& script_path)
{
    size_t dot_pos = script_path.find_last_of('.');
    if (dot_pos != std::string::npos)
    {
        std::string ext = script_path.substr(dot_pos);
        if (ext == ".py")
            return "python3";
        else if (ext == ".php")
            return "php";
        else if (ext == ".pl")
            return "perl";
        else if (ext == ".sh")
            return "sh";
    }
    return "python3";
}

// Configuration des variables d'environnement CGI
void ft_setup_cgi_environment(const HttpRequest& request, const std::string& server_name,
                              int server_port, const std::string& script_path)
{
    setenv("REQUEST_METHOD", request.getMethod().c_str(), 1);
    
    std::string query_string = ft_extract_query_string(request.getTarget());
    setenv("QUERY_STRING", query_string.c_str(), 1);
    
    setenv("SERVER_NAME", server_name.c_str(), 1);
    
    std::ostringstream port_stream;
    port_stream << server_port;
    setenv("SERVER_PORT", port_stream.str().c_str(), 1);
    
    setenv("CONTENT_LENGTH", "0", 1);
    setenv("SCRIPT_NAME", script_path.c_str(), 1);
    setenv("SERVER_PROTOCOL", "HTTP/1.1", 1);
    setenv("GATEWAY_INTERFACE", "CGI/1.1", 1);
}

// Processus enfant pour l'exécution CGI
void ft_execute_cgi_child(const std::string& script_path, const HttpRequest& request,
                          const std::string& server_name, int server_port,
                          int pipe_in[2], int pipe_out[2])
{
    dup2(pipe_in[0], STDIN_FILENO);
    dup2(pipe_out[1], STDOUT_FILENO);
    
    close(pipe_in[0]); 
    close(pipe_in[1]);
    close(pipe_out[0]); 
    close(pipe_out[1]);
    
    chdir("./www/");
    
    ft_setup_cgi_environment(request, server_name, server_port, script_path);
    
    std::string interpreter = ft_get_interpreter(script_path);
    std::string script_name;
    size_t last_slash = script_path.find_last_of('/');
    if (last_slash != std::string::npos)
        script_name = script_path.substr(last_slash + 1);
    else
        script_name = script_path;
    
    char *args[] = {const_cast<char*>(interpreter.c_str()), 
                    const_cast<char*>(script_name.c_str()), NULL};
    execvp(interpreter.c_str(), args);
    
    exit(1);
}

// Fonction pour parser les headers CGI et créer la réponse
HttpResponse ft_parse_cgi_headers(const std::string& headers_part, const std::string& body_part)
{
    HttpResponse response;
    std::istringstream header_stream(headers_part);
    std::string header_line;
    bool has_content_type = false;
    
    while (std::getline(header_stream, header_line))
    {
        if (header_line.empty() || header_line == "\r")
            continue;
            
        size_t colon_pos = header_line.find(':');
        if (colon_pos != std::string::npos)
        {
            std::string header_name = header_line.substr(0, colon_pos);
            std::string header_value = header_line.substr(colon_pos + 1);
            
            // Nettoyer les espaces
            while (!header_value.empty() && (header_value[0] == ' ' || header_value[0] == '\t'))
                header_value.erase(0, 1);
            while (!header_value.empty() && (header_value.back() == '\r' || header_value.back() == '\n'))
                header_value.pop_back();
            
            response.setHeaders(header_name, header_value);
            
            if (header_name == "Content-Type")
                has_content_type = true;
        }
    }
    
    // Ajouter Content-Type par défaut si absent
    if (!has_content_type)
        response.setHeaders("Content-Type", "text/html");
    
    // Définir Content-Length
    std::ostringstream length_stream;
    length_stream << body_part.length();
    response.setHeaders("Content-Length", length_stream.str());
    
    // Autres headers standards
    response.setHeaders("Server", "WebServ/1.0");
    response.setHeaders("Connection", "close");
    
    return response;
}

// Fonction pour construire une réponse HTTP à partir de la sortie CGI
HttpResponse ft_build_cgi_response(const std::string& cgi_output)
{
    HttpResponse response;
    
    // Séparer headers et body
    size_t header_end = cgi_output.find("\r\n\r\n");
    if (header_end == std::string::npos)
        header_end = cgi_output.find("\n\n");
    
    std::string headers_part;
    std::string body_part;
    
    if (header_end != std::string::npos)
    {
        headers_part = cgi_output.substr(0, header_end);
        if (cgi_output.find("\r\n\r\n") != std::string::npos)
            body_part = cgi_output.substr(header_end + 4);
        else
            body_part = cgi_output.substr(header_end + 2);
    }
    else
    {
        body_part = cgi_output;
        headers_part = "Content-Type: text/html";
    }
    
    // Configurer la réponse de base
    response.setVersion("HTTP/1.1");
    response.setStatusCode(200);
    response.setReason("OK");
    
    // Parser les headers CGI
    response = ft_parse_cgi_headers(headers_part, body_part);
    
    // Définir le body
    response.setBody(body_part);
    
    return response;
}

// Fonction pour créer une réponse d'erreur CGI
HttpResponse ft_create_cgi_error(int code, const std::string& reason, const std::string& message)
{
    HttpResponse error_response;
    error_response.setVersion("HTTP/1.1");
    error_response.setStatusCode(code);
    error_response.setReason(reason);
    
    std::string body = "<html><body><h1>" + std::to_string(code) + " " + reason + "</h1><p>" + message + "</p></body></html>";
    error_response.setBody(body);
    
    std::ostringstream length_stream;
    length_stream << body.length();
    error_response.setHeaders("Content-Length", length_stream.str());
    error_response.setHeaders("Content-Type", "text/html");
    error_response.setHeaders("Connection", "close");
    
    return error_response;
}

// Fonction principale pour exécuter un script CGI - retourne HttpResponse
HttpResponse ft_execute_cgi(const std::string& script_path, const HttpRequest& request, 
                           const std::string& server_name, int server_port)
{
    int pipe_in[2], pipe_out[2];
    
    if (pipe(pipe_in) == -1 || pipe(pipe_out) == -1)
    {
        return ft_create_cgi_error(500, "Internal Server Error", "Failed to create pipes for CGI execution");
    }
    
    pid_t pid = fork();
    if (pid == -1)
    {
        close(pipe_in[0]); 
        close(pipe_in[1]);
        close(pipe_out[0]); 
        close(pipe_out[1]);
        return ft_create_cgi_error(500, "Internal Server Error", "Failed to fork process for CGI execution");
    }
    
    if (pid == 0)
    {
        ft_execute_cgi_child(script_path, request, server_name, server_port, pipe_in, pipe_out);
    }
    
    close(pipe_in[0]);
    close(pipe_in[1]);
    close(pipe_out[1]);
    
    std::string cgi_output;
    char buffer[4096];
    ssize_t bytes_read;
    
    while ((bytes_read = read(pipe_out[0], buffer, sizeof(buffer) - 1)) > 0)
    {
        buffer[bytes_read] = '\0';
        cgi_output += buffer;
    }
    
    close(pipe_out[0]);
    
    int status;
    waitpid(pid, &status, 0);
    
    if (WEXITSTATUS(status) != 0)
    {
        return ft_create_cgi_error(500, "Internal Server Error", "CGI script execution failed");
    }
    
    return ft_build_cgi_response(cgi_output);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   DeleteHandler.cpp                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:43:14 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:43:15 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"


HttpResponse    Server::generate_delete_response(HttpRequest &req)
{
    HttpResponse res;

    std::string target = req.getTarget();
    std::string path = "./www" + target;
    std::string parent = path.substr(0, path.find_last_of('/'));

    struct stat st;

    //Check existence
    if (stat(path.c_str(), &st) < 0)
    {
        if (errno == EACCES)
            return generate_error_response(403, "Forbidden", "You do not have permission to access this resource.");
        else
        {
            return generate_error_response(404, "Not Found", "The requested resource does not exist.");
        }
    }
    //get the information on that location

    //WATCH OUT HERE WHAT TO DO IF THERE IS NOTHING
    std::string location_path = target.substr(0, target.find_last_of('/'));
    std::cout << "HERE : " << target << " " << location_path << std::endl;
    std::map<std::string, LocationBloc>::iterator it = this->_locations.find(location_path);

    if (it == this->_locations.end())
    {
        generate_error_response(404, "Not Found", "The requested ressource does not exist");
    }

    LocationBloc location = it->second;
    std::cout << parent <<  std::endl;
    location.print();

    //check if DELETE is an accepted method in the location
    if(std::find(location.allowed_methods.begin(), location.allowed_methods.end(), "DELETE") == location.allowed_methods.end())
        return generate_error_response(405, "Method Not Allowed", "Requested location doesn't serve DELETE method");
    
    //if it is a directory
    if (S_ISDIR(st.st_mode))
    {
            return generate_error_response(403, "Forbidden", "Directory removal is prohibited");
    }

    //unreadable file
    if (access(path.c_str(), F_OK) < 0)
    {
        return generate_error_response(404, "Not Found", "Requested ressource does not exist");
    }

    //checks parent permissions
    if (access(parent.c_str(), W_OK | X_OK) < 0)
    {
        return generate_error_response(403, "Forbidden", "You do not have permissions to access this ressource");
    }

    if (std::remove(path.c_str()))
    {
        return generate_error_response(500, "Internal Server Error", "Unexpected Server Error");
    }

    //Build success response
    return generate_success_response(200, "OK", "Ressource was successfully deleted");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   GetHandler.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:41:30 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/22 00:00:00 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

// Déclarations des fonctions CGI (définies dans CgiHandler.cpp)
HttpResponse ft_execute_cgi(const std::string& script_path, const HttpRequest& request, 
                           const std::string& server_name, int server_port);
bool ft_is_cgi_script(const std::string& file_path);

std::string generate_autoindex_string(const std::string &path, const std::string &target)
{
    std::ostringstream stream;

    stream << "<html>\n<body>\n<ul>\n";

    DIR *dir = opendir(path.c_str());
    if (!dir)
    {
        stream << "<li>Permission denied</li>\n";
        stream << "</ul>\n</body>\n</html>\n";
        return stream.str();
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL)
    {
        std::string name = entry->d_name;

        if (name == "." || name == "..")
            continue;

        if (!name.empty() && name[0] == '.')
            continue;

        struct stat st;
        std::string fullpath = path + "/" + name;
        std::string href = target;
        if (href[href.size() - 1] != '/')
            href += "/";
        href += name;

        if (stat(fullpath.c_str(), &st) == 0 && S_ISDIR(st.st_mode))
        {
            stream << "<li><a href=\"" << href << "/\">" << name << "/</a></li>\n";
        } 
        else
        {
            stream << "<li><a href=\"" << href << "\">" << name << "</a></li>\n";
        }
    }
    closedir(dir);
    stream << "</ul>\n</body>\n</html>\n";
    return (stream.str());
}

HttpResponse    Server::generate_autoindex_response(const std::string &path, const std::string &target)
{
    std::string body;

    body = generate_autoindex_string(path, target);
    return generate_success_response(200, "OK", body);
}

std::string get_content_Type(std::string file)
{
    size_t      dot_pos;
    std::string content_type;
    std::string ext;

    dot_pos = file.find_last_of('.');
    if (dot_pos != std::string::npos)
        ext = file.substr(dot_pos);
    else 
        ext = "";

    if (ext == ".html" || ext == ".htm")
        content_type = "text/html";
    else if (ext == ".css")
        content_type = "text/css";
    else if (ext == ".js")
        content_type = "application/javascript";
    else if (ext == ".txt")
        content_type = "text/plain";
    else if (ext == ".png")
        content_type = "image/png";
    else if (ext == ".gif")
        content_type = "image/gif";
    else if (ext == ".ico")
        content_type = "image/x-icon";
    else if (ext == ".jpeg" || ext == ".jpg")
        content_type = "image/jpeg";
    else if (ext == ".webp")
        content_type = "image/webp";
    else if (ext == ".svg")
        content_type = "image/svg+xml";
    else if (ext == ".pdf")
        content_type = "application/pdf";
    else if (ext == ".php")
        content_type = "cgi/php";
    else if (ext == ".py")
        content_type = "cgi/py";
    else
        content_type = "application/octet-stream";
    return (content_type);
}
HttpResponse Server::generate_get_response(HttpRequest &req)
{
    HttpResponse res;

    std::string target = req.getTarget();
    std::string path = "./www" + target;

    // DEBUG: Ajouter ces logs
    std::cout << "=== DEBUG GET HANDLER ===" << std::endl;
    std::cout << "Target: '" << target << "'" << std::endl;
    std::cout << "Path: '" << path << "'" << std::endl;
    
    // Vérifier si le fichier www/index.html existe vraiment
    struct stat index_check;
    std::string index_path = "./www/index.html";
    if (stat(index_path.c_str(), &index_check) == 0)
        std::cout << "index.html EXISTS in ./www/" << std::endl;
    else
        std::cout << "index.html NOT FOUND in ./www/ (errno: " << errno << ")" << std::endl;
    
    struct stat st;

    if (stat(path.c_str(), &st) < 0)
    {
        std::cout << "stat() failed for path: " << path << " (errno: " << errno << ")" << std::endl;
        if (errno == EACCES)
            return generate_error_response(403, "Forbidden", "You do not have permission to access this resource.");
        else
        {
            return generate_error_response(404, "Not Found", "The requested resource does not exist.");
        }
    }

    std::cout << "Path exists and stat() succeeded" << std::endl;

    // Detecter et executer les scripts CGI
    if (ft_is_cgi_script(path))
    {
        std::cout << "=== CGI SCRIPT DETECTED ===" << std::endl;
        std::cout << "Executing CGI script: " << path << std::endl;
        
        // Executer le script CGI avec la bonne signature (4 arguments)
        return ft_execute_cgi(path, req, "localhost", 8083);
    }
    else
    {
        std::cout << "NOT a CGI script: " << path << std::endl;
    }

    LocationBloc location = (this->_locations)[target];
    std::cout << "Using location: '" << target << "'" << std::endl;
    std::cout << "Location index: '" << location.index << "'" << std::endl;

    if(std::find(location.allowed_methods.begin(), location.allowed_methods.end(), "GET") == location.allowed_methods.end())
        return generate_error_response(405, "Method Not Allowed", "Requested location doesn't serve GET method");
    
    if (S_ISDIR(st.st_mode))
    {
        std::cout << "Path is a directory" << std::endl;
        std::string default_path = path;
        if (default_path[default_path.size() - 1] != '/')
            default_path += "/";

        // CORRECTION ICI : traiter location.index comme un string, pas un vector
        if (!location.index.empty())
        {
            std::string index_file_path = default_path + location.index;
            std::cout << "Checking index file: " << index_file_path << std::endl;
            
            struct stat index_st;
            if (stat(index_file_path.c_str(), &index_st) == 0 && S_ISREG(index_st.st_mode))
            {
                std::cout << "Found index file: " << index_file_path << std::endl;
                path = index_file_path;
                goto serve_file;
            }
            else
            {
                std::cout << "Index file not found or not regular: " << index_file_path << std::endl;
            }
        }
        
        std::cout << "No index file found. Autoindex: " << (location.autoindex ? "ON" : "OFF") << std::endl;
        
        if (location.autoindex == true)
        {
            return generate_autoindex_response(path, target);
        }
        else
        {
            return generate_error_response(403, "Forbidden", "Directory listing is not allowed and no index file was found.");
        }
    }

serve_file:
    std::cout << "Serving file: " << path << std::endl;
    std::ifstream file(path.c_str(), std::ios::binary);
    if (!file.is_open())
        return generate_error_response(403, "Forbidden", "You do not have permission to access this resource.");

    std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
    file.close();

    std::string content_type = get_content_Type(path);

    std::cout << "=== END DEBUG ===" << std::endl;
    return generate_success_response(200, "OK", content);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HandleErrors.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/12 14:32:06 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/12 14:32:07 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "../../includes/main.hpp"


HttpResponse Server::generate_success_response(int code, const std::string &reason, const std::string &body)
{
    HttpResponse res;

    res.setVersion("HTTP/1.1");
    res.setStatusCode(code);
    res.setReason(reason);

    res.setHeaders("Content-Type", "text/html");
    res.setHeaders("Content-Length", std::to_string(body.size()));
    res.setHeaders("Connection", "close");
    res.setBody(body);

    return (res);
}

HttpResponse Server::generate_error_response(int code, const std::string &reason, const std::string &details)
{
    HttpResponse res;

    res.setVersion("HTTP/1.1");
    res.setStatusCode(code);
    res.setReason(reason);

    std::string body = "<html><body><h1>" + std::to_string(code) + " " + reason + "</h1><p>" + details + "</p></body></html>";

    res.setHeaders("Content-Type", "text/html");
    res.setHeaders("Content-Length", std::to_string(body.size()));
    res.setHeaders("Connection", "close");
    res.setBody(body);

    return (res);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   PostHandler.cpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:42:38 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:42:39 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

std::string get_content_Type(std::string file);

static char fromHex(char c)
{
    if (c >= '0' && c <= '9')
        return (c - '0');
    if (c >= 'A' && c <= 'F')
        return (c - 'A' + 10);
    if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);
    return 0;
}

static std::string urlDecode(const std::string &src)
{
    std::string result;

    for (size_t i = 0; i < src.size(); ++i)
    {
        if (src[i] == '%' && i + 2 < src.size() && std::isxdigit(src[i+1]) && std::isxdigit(src[i+2]))
        {
            char h1 = src[i+1];
            char h2 = src[i+2];
            char decoded = (fromHex(h1) << 4) | fromHex(h2);
            result.push_back(decoded);
            i += 2;
        }
        else if (src[i] == '+')
        {
            result.push_back(' ');
        }
        else
        {
            result.push_back(src[i]);
        }
    }
    return result;
}

std::map<std::string, std::string> parse_raw_body(const std::string &body)
{
    std::map<std::string, std::string> result;
    std::string pair;
    std::istringstream ss(body);

    while (std::getline(ss, pair, '&'))
    {
        size_t pos = pair.find('=');
        if (pos != std::string::npos)
        {
            std::string key = pair.substr(0, pos);
            std::string value = pair.substr(pos + 1);

            //some chars are transformed by the browser like %10 or space becomes +
            key = urlDecode(key);
            value = urlDecode(value);
            result[key] = value;
        }
    }
    return result;
}

HttpResponse    Server::generate_post_response(HttpRequest &req)
{
    HttpResponse res;

    std::string target = req.getTarget();
    std::string path = "./www" + target;

    struct stat st;

    //Check existence
    if (stat(path.c_str(), &st) < 0)
    {
        if (errno == EACCES)
            return generate_error_response(403, "Forbidden", "You do not have permission to access this resource.");
        else
        {
            return generate_error_response(404, "Not Found", "The requested resource does not exist.");
        }
    }
    //get the information on that location
    LocationBloc location = (this->_locations)[target];

    //check if POST is an accepted method in the location
    if(std::find(location.allowed_methods.begin(), location.allowed_methods.end(), "POST") == location.allowed_methods.end())
        return generate_error_response(405, "Method Not Allowed", "Requested location doesn't serve POST method");

    //if target is a directory
    if (S_ISDIR(st.st_mode))
    {
        //if the body is a generic query-string like body -> create a file
        std::map<std::string, std::string>::const_iterator it = req.getHeaders().find("Content-Type");
        if (it != req.getHeaders().end() && it->second == "application/x-www-form-urlencoded")
        {
            std::map<std::string, std::string> sorted_body = parse_raw_body(req.getBody());
            it = sorted_body.find("filename");
            if (it == sorted_body.end())
            {
                return generate_error_response(400, "Bad Request", "Missing filename");
            }
            std::string file_path = path + "/" + it->second;
            int fd = open((file_path).c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (fd < 0)
            {
                std::cout << "HERE : " << file_path << std::endl;
                return generate_error_response(500, " Internel Server Error", "File exists but read failed");
            }
            //if there is content write it
            it = sorted_body.find("content");
            if (it != sorted_body.end())
                write(fd, (it->second).c_str(), (it->second).size());

            close(fd);
        }

        //if we multipart -> relocate a file
        else if (it != req.getHeaders().end() && it->second == "multipart/form-data")
        {
            //this is incorrect. look up how multipart functions
            //int fd = open(path.c_str(), O_WRONLY | O_CREAT | O_TRUNC);
            ////open failure
            //if (fd < 0)
            //{
            //    return generate_error_response(500, "Internel Server Error", "File exists but read failed");
            //}
            //write(fd, req.getBody().c_str(), req.getBody().size());
            //close(fd);
        }
        else
        {


        } 
        return generate_success_response(201, "OK", "");
    }

    //if it is a file
    else if (!S_ISREG(st.st_mode))
    {
        return generate_error_response(403, "Forbidden", "Requested ressource is not regular file");
    }

    //unreadable file
    if (access(path.c_str(), R_OK) < 0)
    {
        return generate_error_response(403, "Forbidden", "Requested Ressource is unreadable");
    }
    return (res);

}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:39:36 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:39:37 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

Server::Server()
    : _listen(-1),
      _root("./www"),
      _name("localhost"),
      _index("index.html"),
      _autoindex(false),
      _allowed_methods(1, "GET"),
      _client_max_body_size(1000000),
      _locations(),
      _server_fd(-1),
      _max_fd(-1)
{
    std::memset(&_address, 0, sizeof(_address));
    FD_ZERO(&_read_fds);
    FD_ZERO(&_write_fds);
    FD_ZERO(&_master_fds);
    _client_fds.clear();
}



Server::Server(ServerBloc &s)
    : _root(s.root),
    _name(s.name),
    _index(s.index),
    _autoindex(false),
    _allowed_methods(s.allowed_methods),
    _client_max_body_size(s.client_max_body_size),
    _locations(s.locations),
    _listen(s.listen),
    _server_fd(-1),
    _max_fd(-1)
{
    std::memset(&_address, 0, sizeof(_address));
    FD_ZERO(&_read_fds);
    FD_ZERO(&_write_fds);
    FD_ZERO(&_master_fds);
    _client_fds.clear();
}


Server::~Server()
{
    this->shutdown();
}

void Server::shutdown()
{
    //closing all client sockets
    for (size_t i = 0; i < _client_fds.size(); i++)
    {
        if (_client_fds[i] >= 0)
            close(_client_fds[i]);
    }
    _client_fds.clear();

    //closing listening socket
    if (_server_fd >= 0)
    {
        close(_server_fd);
        _server_fd = -1;
    }

    FD_ZERO(&_read_fds);
    FD_ZERO(&_write_fds);
    FD_ZERO(&_master_fds);
}


void Server::init()
{
    //creates a socket
    _server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (_server_fd < 0)
        throw std::runtime_error("socket creation failure");

    //allows address reuse
    int opt = 1;
    if (setsockopt(_server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
    {
        close(_server_fd);
        throw std::runtime_error("setsockopt failed");
    }

    //fill address structure
    std::memset(&_address, 0, sizeof(_address));
    _address.sin_family = AF_INET;
    _address.sin_addr.s_addr = INADDR_ANY;
    _address.sin_port = htons(_listen);

    //binds socket to IP address
    if (bind(_server_fd, (struct sockaddr*)&_address, sizeof(_address)) < 0)
    {
        close(_server_fd);
        throw std::runtime_error("bind failed for port " + std::to_string(_listen));
    }

    //start listening -> port opened
    if (listen(_server_fd, SOMAXCONN) < 0)
    {
        close(_server_fd);
        throw std::runtime_error("listen failed");
    }

    //initialize fd_sets
    FD_ZERO(&_read_fds);
    FD_ZERO(&_write_fds);
    FD_ZERO(&_master_fds);
    FD_SET(_server_fd, &_master_fds);

    //Track max fd
    //_max_fd = _server_fd;

    std::cout << "Server listening on port..." << _listen << std::endl;
}


void    Server::print()
{
    std::cout << "listen: " << this->_listen <<  std::endl;
    std::cout << "name: " << this->_name <<  std::endl;
    std::cout << "index: " << this->_index <<  std::endl;
    std::cout << "allowed methods: ";
    for (size_t i = 0 ; i < this->_allowed_methods.size(); ++i)
        std::cout << this->_allowed_methods[i] << " ";
    std::cout << std::endl;
    std::cout << "max body size: " << this->_client_max_body_size <<  std::endl;
    std::cout << "autoindex: " << this->_autoindex <<  std::endl;
    std::map<std::string, LocationBloc>::iterator it;
    for (it = this->_locations.begin() ; it != this->_locations.end(); ++it)
    {
        std::cout << "location : " << it->first << ": " << std::endl;
        (it->second).print();
        std::cout << std::endl;
    }
}

//jacob

int Server::get_server_fd(void) const
{
    return _server_fd;
}

int Server::get_last_client_fd(void) const
{
    if (_client_fds.empty())
        return (-1);
    return _client_fds.back();
}

bool Server::is_client_fd(int fd) const
{
    size_t i = 0;
    while (i < _client_fds.size())
    {
        if (_client_fds[i] == fd)
            return true;
        i++;
    }
    return false;
}

void Server::accept_new_client(void)
{
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);

    int client_fd = accept(_server_fd, (struct sockaddr*)&client_addr, &client_len);
    if (client_fd < 0)
        return; //no clients to accept

    //make the client non blocking
    if (fcntl(client_fd, F_SETFL, O_NONBLOCK) < 0)
    {
        close(client_fd);
        return;
    }

    //add to clients in the server
    FD_SET(client_fd, &_master_fds);
    _client_fds.push_back(client_fd);
    
    if (client_fd > _max_fd)
        _max_fd = client_fd;

    std::cout << "New client connected to server " << _name << std::endl;
}

HttpResponse    Server::generate_response(HttpRequest &req)
{
    HttpResponse    res;
    std::string     method = req.getMethod();

    //if request was malformed
    if (req.getFlag() == 400)
    {
        res =  res = generate_error_response(400, "Bad Request", "The browser sent a request that this server could not understand");
    }
    if (method == "GET")
    {
        res = generate_get_response(req);
    }
    else if (method == "POST")
    {
        res = generate_post_response(req);
    }
    else if (method == "DELETE")
    {
        res = generate_delete_response(req);
    }
    else
    {
        res = generate_error_response(501, "Not Implemented", "This method is not supported by the server");
    }
    return (res);
}

void Server::handle_client_request(int client_fd)
{
    //what if i receive a bigger size than 4096????????????????????????????????????????
    char buffer[4096];
    ssize_t bytes_read = recv(client_fd, buffer, 4095, 0);
    
    //if recv failed or nothing to read
    if (bytes_read <= 0)
    {
        disconnect_client(client_fd);
        return;
    }

    buffer[bytes_read] = '\0';
    std::cout << "Received: " << buffer << std::endl;

    //create a http request object
    HttpRequest req;
    //parse the request based on the buffer
    req.parse(buffer);
    req.print();

    //create a http response object
    HttpResponse res = generate_response(req);
    res.print();
    
    //get the actual string response
    std::string response = res.toStr();

    //send the response to the client fd
    send(client_fd, response.c_str(), response.length(), 0);
    disconnect_client(client_fd);
}

void Server::disconnect_client(int client_fd)
{
    close(client_fd);
    FD_CLR(client_fd, &_master_fds);
    
    //remove from client list
    size_t i = 0;
    while (i < _client_fds.size())
    {
        if (_client_fds[i] == client_fd)
        {
            _client_fds.erase(_client_fds.begin() + i);
            break;
        }
        i++;
    }
    std::cout << "Client " << " disconnected from server " << _name << std::endl;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerMonitor.cpp                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:39:14 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:39:16 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"

int ServerMonitor::_flag = 0;

ServerMonitor::ServerMonitor()
{

}

ServerMonitor::ServerMonitor(std::string &config) : _config(config) , _max_fd(0)
{
    FD_ZERO(&(this->_master_fds));
}


ServerMonitor::~ServerMonitor()
{
    FD_ZERO(&_master_fds);
    for (size_t i = 0; i < _servers.size(); i++)
    {
        _servers[i].shutdown(); // each Server closes its fds and clears them
    }
}

void    ServerMonitor::print()
{
    int j = 1;

    for (size_t i = 0; i < this->_servers.size(); ++i, j++)
    {
       std::cout << "\033[34mSERVER " << j << "\033[0m" << std::endl;
        (this->_servers[i]).print();
        std::cout << "------------------------" << "\n" << std::endl;
    }
    std::cout << std::endl;
}

void ServerMonitor::handle_sigint(int signum)
{
    std::cout << "\nSIGINT received, shutting down servers...\n";
    ServerMonitor::_flag = -1;
}

void    ServerMonitor::addServer(Server server)
{
    _servers.push_back(server);
    //add the fd aswell
}

void    ServerMonitor::init_servers()
{
    //init the sockets (FD) of each servers
    for (size_t i = 0; i < this->_servers.size(); i++)
    {
        try { (this->_servers[i]).init();}
        catch (std::exception &e) {throw;}
    }
    
    //add all the servers fd's in master_fds
    size_t i = 0;
    while (i < _servers.size())
    {
        //get the fd from the server
        int server_fd = _servers[i].get_server_fd();

        //add it to the set
        FD_SET(server_fd, &(this->_master_fds));

        //track the biggest fd
        if (server_fd > this->_max_fd)
            this->_max_fd = server_fd;
        i++;
    }
}


void ServerMonitor::run()
{
    if (_servers.empty())
    {
        std::cerr << "No servers to run!" << std::endl;
        return;
    }

    std::cout << "Starting server(s) with " << _servers.size() << " listening socket(s)..." << std::endl;

    fd_set read_fds;

    //main loop
    while (ServerMonitor::_flag == 0)
    {
        read_fds = this->_master_fds; //copy master into read_fds

        std::cout << "\nWaiting for clients..." << std::endl;

        int activity = select(this->_max_fd + 1, &read_fds, NULL, NULL, NULL);
        //for signal handling
        if (errno == EINTR)
            break ;
        if (activity < 0)
            throw std::runtime_error("Select Error");

        //loop through servers
        for (size_t i = 0; i < _servers.size(); i++)
        {
            int server_fd = _servers[i].get_server_fd();

            //new connection on this server
            if (FD_ISSET(server_fd, &read_fds))
            {
                _servers[i].accept_new_client();

                int new_client = _servers[i].get_last_client_fd();
                if (new_client > 0)
                {
                    FD_SET(new_client, &(this->_master_fds));
                    if (new_client > this->_max_fd)
                        this->_max_fd = new_client;        
                }
            }

            //loop through all potential client fds
            for (int fd = 0; fd <= this->_max_fd; fd++)
            {
                if (FD_ISSET(fd, &read_fds) && fd != server_fd && _servers[i].is_client_fd(fd))
                {
                    _servers[i].handle_client_request(fd);

                    if (!_servers[i].is_client_fd(fd))
                    {
                        FD_CLR(fd, &(this->_master_fds));
                    }
                }
            }
        }
    }
}

LocationBloc    get_location_bloc(std::vector<std::string> &tokens, std::string &pathi, size_t *i)
{
    LocationBloc                location;
    std::vector<std::string>    key_values;


    location.path = pathi;
    (*i)++;
    for (; tokens[*i] != "}"; ++(*i))
    {
        while (*i < tokens.size() && tokens[*i] != ";" && tokens[*i] != "{" && tokens[*i] != "}")
        {
            key_values.push_back(tokens[*i]);
            (*i)++;
        }
        std::cout << "location key value : ";
        for (int j = 0; j < key_values.size(); ++j)
            std::cout << key_values[j] << " ";
        std::cout << std::endl;
        if (key_values.empty())
            continue ;
        if (key_values.size() < 2)
             throw std::runtime_error(key_values[0] + ": no value for this token");

        if (key_values[0] == "root")
        {
            location.root = key_values[1];
        }
        else if (key_values[0] == "index")
        {
            location.index = key_values[1];
        }
        else if (key_values[0] == "allowed_methods")
        {
            location.allowed_methods.clear();
            for (int l = 1; l < key_values.size(); ++l)
                location.allowed_methods.push_back(key_values[l]);
        }
        else if (key_values[0] == "client_max_body_size")
        {
            try{location.client_max_body_size = safe_atosize_t(key_values[1]);}
                catch (std::exception &e) {throw;}
        }
        else if (key_values[0] == "autoindex")
        {
            if (key_values[1] == "on")
                location.autoindex = true;
        }
        //non recognised token
        else 
        {
            throw std::runtime_error(key_values[0] + ": token not recognised");
        }
        key_values.clear();
    }
    return (location);
}

ServerBloc  get_server_bloc(std::vector<std::string> &tokens)
{
    std::vector<std::string>    key_values;
    ServerBloc                  sbloc;

    for (size_t i = 1; i < tokens.size(); ++i)
    {
        while (i < tokens.size() && tokens[i] != ";" && tokens[i] != "{" && tokens[i] != "}")
        {
            key_values.push_back(tokens[i]);
            i++;
        }
        std::cout << "server key value : ";
        for (int j = 0; j < key_values.size(); ++j)
            std::cout << key_values[j] << " ";
        std::cout << std::endl;

        if (key_values.empty())
            continue ;

        if (key_values.size() < 2)
            throw std::runtime_error(key_values[0] + ": no value for this token");

        if (key_values[0] == "allowed_methods")
        {
            sbloc.allowed_methods.clear();
            for (int l = 1; l < key_values.size(); ++l)
                sbloc.allowed_methods.push_back(key_values[l]);
        }
        else if (key_values.size() > 2)
            throw std::runtime_error(key_values[2] + ": unrecognized value");
        else if (key_values[0] == "listen")
        {
            try{sbloc.listen = safe_atosize_t(key_values[1]);}
            catch (std::exception &e) {throw;}
        }
        else if (key_values[0] == "server_name")
        {
            sbloc.name = key_values[1];
        }
        else if (key_values[0] == "root")
        {
            sbloc.root = key_values[1];
        }
        else if (key_values[0] == "index")
        {
            sbloc.index = key_values[1];
        }
        else if (key_values[0] == "client_max_body_size")
        {
            try{sbloc.client_max_body_size = safe_atosize_t(key_values[1]);}
            catch (std::exception &e) {throw;}
        }
        else if (key_values[0] == "autoindex")
        {
            if (key_values[1] == "on")
                sbloc.autoindex = true;
        }
        else if (key_values[0] == "location")
        {
            try { sbloc.locations[key_values[1]] = get_location_bloc(tokens, key_values[1], &i);}
            catch (std::exception &e){throw;}
        }
        //non recognised token
        else 
        {
            throw std::runtime_error(key_values[0] + ": token not recognised");
        }
        key_values.clear();
    }
    return (sbloc);
}

bool    is_valid_server_bloc(ServerBloc &sbloc)
{
    //if there are no root or no listen ->error
    if (sbloc.listen == -1)
        return (false);
    if (sbloc.root.empty())
        return (false);
    return (true);
}

bool ServerMonitor::valid_semicolons(const std::vector<std::string> &tokens)
{
    for (size_t i = 0; i < tokens.size(); ++i)
    {
        const std::string &tok = tokens[i];

        //if it's a block opener
        if (tok == "server")
        {
            if (i + 1 >= tokens.size() || tokens[i + 1] != "{")
                throw std::runtime_error("config file: server must be followed by {");
        }

        else if (tok == "location")
        {
            if (i + 2 >= tokens.size() || tokens[i + 2] != "{")
                throw std::runtime_error("config file: location must be followed by a name and then a {");
            i+=2;
        }
        //if it's a normal directive
        else if (tok != "{" && tok != "}" && tok != ";")
        {
            //find end of this directive
            size_t j = i + 1;
            while (j < tokens.size() && tokens[j] != ";" && tokens[j] != "{" && tokens[j] != "}")
                j++;

            //check we ended with a semicolon
            if (j >= tokens.size() || tokens[j] != ";")
                throw std::runtime_error("config file: missing ; after " + tok);

            //skip ahead to after semicolon
            i = j;
        }
    }
    return true;
}

bool ServerMonitor::valid_brackets(const std::vector<std::string> &tokens)
{
    //checking brackets count
    int depth = 0;
    for (size_t i = 0; i < tokens.size(); ++i)
    {
        if (tokens[i] == "{")
            depth++;
        if (tokens[i] == "}")
            depth--;
        if (depth < 0)
            throw std::runtime_error("config file: too many '}'");
    }
    if (depth != 0)
        throw std::runtime_error("config file: missing closing '}'");


    for (size_t i = 0; i < tokens.size(); ++i)
    {
        //Checks brackets server
        if (tokens[i] == "server")
        {
            if ((i + 1) >= tokens.size() || tokens[i + 1] != "{")
                throw std::runtime_error("config file: missing '{' after server");
            if (i > 0 && tokens[i - 1] != "}")
                throw std::runtime_error("config file: 'server' must start a block or follow '}'");
        }

        //Checks brackets location
        if (tokens[i] == "location")
        {
            if (i + 1 >= tokens.size() || tokens[i + 1] == "{" || tokens[i + 1] == "}" || tokens[i + 1] == ";")
                throw std::runtime_error("config file: missing location path after location");
            if (i + 2 >= tokens.size() || tokens[i + 2] != "{")
                throw std::runtime_error("config file: missing '{' after location");
        }

        //checks stray '{'
        if (tokens[i] == "{")
        {
            if (i == 0)
                throw std::runtime_error("config file: unexpected '{' at start");
            if (tokens[i - 1] != "server" && tokens[i - 2] != "location")
                throw std::runtime_error("config file: unexpected '{' near " + tokens[i-1]);
        }
    }
    return true;
}

std::vector<std::string>    ServerMonitor::tokenize(const std::string &buffer)
{
    std::vector<std::string>    tokens;
    std::string                 current;

    for (size_t i = 0; i < buffer.size(); ++i)
    {
        //end of a token when there is a space
        if (buffer[i] == ' ' || buffer[i] == '}' || buffer[i] == '{' || buffer[i] == ';')
        {
            if (!current.empty())
                tokens.push_back(current);
            if (buffer[i] == '}')
                tokens.push_back("}");
            else if (buffer[i] == '{')
                tokens.push_back("{");
            else if (buffer[i] == ';')
                tokens.push_back(";");
            current.clear();
        }
        else
        {
            current.push_back(buffer[i]);
        }
    }
    if (!current.empty())
        tokens.push_back(current);
    return (tokens);
}

void    ServerMonitor::parse()
{
    std::string                 trimmed;
    std::string                 line;
    std::ostringstream          buffer;
    std::vector<std::string>    tokens;

    //opening file
    std::ifstream   file(_config);
    if (!file.is_open())
        throw std::runtime_error(_config + ": failed to open");
    //constructing string containing everything
    while (std::getline(file, line))
    {
        trimmed = trimmer(line);
        if (!line.empty())
            buffer << trimmed;
    }
    file.close();
    trimmed = buffer.str();
    std::cout << "BUFFER STRING :\n" << trimmed << "\n" << std::endl; 

    //tokenizing the whole string
    std::cout << "TOKENS : ";
    tokens = tokenize(trimmed);
    for (int i = 0; i < tokens.size(); ++i)
            std::cout << tokens[i] << " ";
    std::cout << "\n" << std::endl;
    
    //check bracket placement
    try{valid_brackets(tokens);}
    catch (std::exception &e)    {throw;}

    //check semicolon placement
    try{valid_semicolons(tokens);}
    catch (std::exception &e)    {throw;}

    //tokenize2 : assemble key values, ';' dissapear but brackets remain
    std::vector<std::string>    vserver;
    //looping through all the servers
    for (size_t i = 1; i < tokens.size(); ++i)
    {
        //looping untill a server blov is finished
        while (i < tokens.size() && tokens[i] != "server")
        {
            vserver.push_back(tokens[i]);
            i++;
        }

        std::cout << "SERVER BLOCK" << std::endl;
        for (int j = 0; j < vserver.size(); ++j)
            std::cout << vserver[j] << std::endl;
        std::cout << std::endl << std::endl;

        //creating the server bloc
        ServerBloc sbloc = get_server_bloc(vserver);
        vserver.clear();

        //check if it is valid. if so create an actual server
        if (is_valid_server_bloc(sbloc))
        {
            //!this can fail when using sytem calls!
            try 
            {
                Server server(sbloc);
                this->addServer(server);
            }
            catch (std::exception &e) {throw;}
        }
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   str_utils.cpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/10 13:14:02 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/10 13:14:21 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/main.hpp"


std::string trimmer(std::string &str)
{
    std::string                 trimmed;

    //all comments supressed
    trimmed = commenttrim(str);
    //trims leading and trailing whitespaces
    trimmed = strtrim(trimmed);
    //allows only one space between elements of a line
    trimmed = spacetrim(trimmed);
    //allows no spaces between brackets
    trimmed = brackettrim(trimmed);
    return (trimmed);
}


std::vector<std::string> ft_split(const std::string &line, const std::string &separators)
{
    std::vector<std::string> tokens;
    size_t start = 0;
    size_t pos;

    while (start < line.size())
    {
        // find first non-separator
        start = line.find_first_not_of(separators, start);
        if (start == std::string::npos)
            break;

        // find next separator after that
        pos = line.find_first_of(separators, start);
        if (pos == std::string::npos)
        {
            tokens.push_back(line.substr(start));
            break;
        }
        else
        {
            tokens.push_back(line.substr(start, pos - start));
            start = pos + 1;
        }
    }

    return tokens;
}

int get_closing_bracket_index(std::string &str)
{
    int     count = 1;
    int     i = 7;

    while (i < str.size())
    {
        if (str[i] == '{')
            count++;
        else if (str[i] == '}')
            count--;
        if (count == 0)
            return (i);
        i++;
    }
    return (i);
}

std::string commenttrim(std::string &str)
{
    std::string trimmed;
    size_t      hash_pos = str.find_first_of("#");

    if (hash_pos == std::string::npos)
        return (str);
    trimmed = str.substr(0, hash_pos);
    return (trimmed);
}

bool    is_closed(std::string str)
{
    int     count = 0;;
    size_t  i = 0;

    while (i < str.size())
    {
        if (str[i] == '{')
            count++;
        else if (str[i] == '}')
            count--;
        if (count < 0)
            return (false);
        i++;
    }

    if (count != 0)
        return (false);
    return (true);
}

std::string spacetrim(std::string &line)
{
    std::ostringstream  str;
    bool                in_space = false;

    for (size_t i = 0; i < line.size(); i++)
    {
        if (line[i] == ' ' || line[i] == '\t' || line[i] == '\r' || line[i] == '\f' || line[i] == '\v')
        {
            if (!in_space)
            {
                str << ' ';
                in_space = true;
            }
        }
        else
        {
            str << line[i];
            in_space = false;
        }
    }
    return (str.str());
}

std::string brackettrim(std::string &line)
{
    std::ostringstream  str;

    for (size_t i = 0; i < line.size(); i++)
    {
        if (line[i] == ' ' || line[i] == '\t' || line[i] == '\r' || line[i] == '\f' || line[i] == '\v')
        {
            if (i != 0 && (line[i - 1] == '}' || line[i - 1] == '{' || line[i - 1] == ';'))
                continue ;
            else if ((i != line.size() - 1) && (line[i + 1] == '}' || line[i + 1] == '{') || line[i + 1] == ';')
                continue ;
            str << line[i];
        }
        else
        {
            str << line[i];
        }
    }
    return (str.str());
}


//put it in utils
std::string strtrim(std::string &str)
{
    size_t      first_valid_char;
    size_t      last_valid_char;
    size_t      length;
    std::string trimmed;

    if (str.empty())
        return ("");
    //finding position of first non space char
    first_valid_char = str.find_first_not_of(" \t\v\f\r");
     if (first_valid_char == std::string::npos)
        return ""; // string is all whitespace
    //finding position of last non space char
    last_valid_char = str.find_last_not_of(" \t\v\f\r");
    //finding the length
    length = last_valid_char - first_valid_char + 1;
    //creating the string
    trimmed = str.substr(first_valid_char, length);
    return (trimmed);
}

size_t safe_atosize_t(const std::string &str)
{
    if (str.empty())
        throw std::runtime_error(str + ": missing value");

    // Check all chars are digits
    for (size_t i = 0; i < str.size(); ++i)
    {
        if (!std::isdigit(str[i]))
            throw std::runtime_error(str + ": invalid characters: " + str);
    }

    // Convert using stringstream
    std::istringstream iss(str);
    std::string str_value = iss.str();
    size_t value = 0;
    iss >> value;

    if (iss.fail())
        throw std::runtime_error(str + ": conversion failed");
    // Overflow check
    if (str_value.size() > 20)
        throw std::runtime_error(str + ": value too large");
    if (value > std::numeric_limits<size_t>::max())
        throw std::runtime_error(str + ": value too large");
    return (value);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Config.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:38:06 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:38:07 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <vector>
#include <map>

struct LocationBloc
{
    std::string                 path;                  
    std::string                 root;                  
    std::vector<std::string>    allowed_methods;  
    size_t                      client_max_body_size;       
    std::string                 index;
    bool                        autoindex;        
    LocationBloc();
    ~LocationBloc();
    void    print();
};

struct ServerBloc
{
    std::string                         root;
    std::string                         name;
    std::string                         index;
    int                                 listen;
    std::vector<std::string>            allowed_methods;
    size_t                              client_max_body_size;
    bool                                autoindex;
    std::map<std::string, LocationBloc> locations;            
    ServerBloc();
    ~ServerBloc();
    void    print();
};/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpRequest.hpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 18:42:33 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 18:42:35 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <map>
#include <vector>

/*  TEMPLATE

first line      GET /index.html HTTP/1.1\r\n
header          Host: localhost:8080\r\n
header          User-Agent: Mozilla/5.0 (X11; Linux x86_64)\r\n
header          Accept: text/html\r\n
header          Connection: keep-alive\r\n
\r\n
body(optional)  {"username":"harold","password":"42"}

*/

class HttpRequest
{
    private:
        std::string                         _buffer;
        std::string                         _method;
        std::string                         _target;
        std::string                         _version;
        std::map<std::string, std::string>  _headers;
        std::string                         _body;
        int                                 _flag;

        //private methods
        bool                        is_valid_request()const;
        std::vector<std::string>    tokenize(const std::string buffer)const;

    public:
        //constructors
        HttpRequest();
        HttpRequest(const HttpRequest &copy);

        //destructors
        ~HttpRequest();

        //getters
        const std::string                           &getMethod()const;
        const std::string                           &getTarget()const;
        const std::string                           &getVersion()const;
        const std::map<std::string, std::string>    &getHeaders()const;
        const std::string                           &getBody()const;
        const int                                   &getFlag()const;


        //public methods
        void                        parse(const std::string &buffer);
        void                        print()const;
};
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpResponse.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 18:42:22 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 18:42:24 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include "HttpRequest.hpp"

/*  TEMPLATE

first line  HTTP/1.1 200 OK\r\n
header      Content-Type: text/html\r\n
header      Content-Length: 32\r\n
header      Connection: close\r\n
\r\n
body        <html><h1>Hello World</h1></html>

*/

class HttpResponse
{
    private:
        std::string                         _version;
        int                                 _statusCode;
        std::string                         _reason;
        std::map<std::string, std::string>  _headers;
        std::string                         _body;


    public:
        //constructors
        HttpResponse();
        HttpResponse(const HttpRequest &req);

        //destructors
        ~HttpResponse();

        //setters
        void    setVersion(const std::string &verion);
        void    setStatusCode(int code);
        void    setReason(const std::string &reason);
        void    setBody(const std::string &body);
        void    setHeaders(const std::string &version, const std::string &second);

        //methods
        std::string toStr();
        void        print();
};
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.hpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 17:48:30 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 17:48:31 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "HttpResponse.hpp"
#include "HttpRequest.hpp"
#include "Server.hpp"
#include "ServerMonitor.hpp"
#include "Config.hpp"
#include <stdexcept>
#include <limits>
#include <sys/types.h>
#include <dirent.h>

std::string                 strtrim(std::string &str);
std::string                 brackettrim(std::string &line);
std::string                 spacetrim(std::string &line);
bool                        is_closed(std::string str);
std::vector<std::string>    ft_split(const std::string &line, const std::string &separators);
int                         get_closing_bracket_index(std::string &str);
std::string                 commenttrim(std::string &str);
size_t                      safe_atosize_t(const std::string &str);
std::string                 trimmer(std::string &str);/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 17:48:36 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 17:48:37 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "Config.hpp"
#include "HttpRequest.hpp"
#include "HttpResponse.hpp"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/wait.h> 
#include <unistd.h>
#include <fcntl.h>
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <stdexcept>
#include <sstream>
#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <sys/stat.h>
#include <cerrno>
#include <cstring>

class Server
{
    private:

        //based on config
        int                                 _listen;
        std::string                         _root;
        std::string                         _name;
        std::string                         _index;
        bool                                _autoindex;
        std::vector<std::string>            _allowed_methods;
        size_t                              _client_max_body_size;
        std::map<std::string, LocationBloc> _locations;

        //basic networking client<->server
        int					_server_fd;
		struct sockaddr_in	_address;
		fd_set				_read_fds;
		fd_set				_write_fds;
		fd_set				_master_fds;
		int					_max_fd;
		std::vector<int>	_client_fds;

    public:
        Server();
        //Server(const Server& other);
        Server(ServerBloc &bloc);
        //Server& operator=(const Server& other);
        ~Server();


        //networking methods
		int     get_server_fd(void) const;
		int     get_last_client_fd(void) const;
		bool    is_client_fd(int fd) const;
		void    accept_new_client(void);
		void    disconnect_client(int client_fd);

        void    init();
        void    print();
        void    shutdown();

        //response methods
        void            handle_client_request(int client_fd);
        HttpResponse    generate_response(HttpRequest &req);
        HttpResponse    generate_success_response(int code, const std::string &reason, const std::string &body);
        HttpResponse    generate_autoindex_response(const std::string &path, const std::string &target);
        HttpResponse    generate_get_response(HttpRequest &req);
        HttpResponse    generate_post_response(HttpRequest &req);
        HttpResponse    generate_delete_response(HttpRequest &req);
        HttpResponse    generate_error_response(int code, const std::string &reason, const std::string &details);



        //cgi 

        std::string     ft_execute_cgi(const std::string& script_path, const HttpRequest& request);
        std::string     ft_build_cgi_response(const std::string& cgi_output);
        std::string     ft_to_upper_env(const std::string& str);
        std::string     ft_get_directory_path(const std::string& file_path);
};/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerMonitor.hpp                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 18:00:37 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 18:00:38 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "Server.hpp"
#include <iostream>
#include <vector>
#include <algorithm>

class ServerMonitor
{
    private:
        std::string             _config;
        std::vector<Server>     _servers;
        fd_set                  _master_fds;
        int                     _max_fd;
        
        //private methods
        std::vector<std::string>    tokenize(const std::string &buffer);
        bool                        valid_brackets(const std::vector<std::string> &tokens);
        bool                        valid_semicolons(const std::vector<std::string> &tokens);
    public:

        //constructors
        ServerMonitor();
        ServerMonitor(std::string &config);

        //destructors
        ~ServerMonitor();

        //public methods
        void    addServer(Server server);
        void    parse();
        void    run();
        void    print();
        void    init_servers();

        //special function and it's special variable
        static void handle_sigint(int signum);
        static int              _flag;
};

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Config.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 19:38:06 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 19:38:07 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <vector>
#include <map>

struct LocationBloc
{
    std::string                 path;                  
    std::string                 root;                  
    std::vector<std::string>    allowed_methods;  
    size_t                      client_max_body_size;       
    std::string                 index;
    bool                        autoindex;        
    LocationBloc();
    ~LocationBloc();
    void    print();
};

struct ServerBloc
{
    std::string                         root;
    std::string                         name;
    std::string                         index;
    int                                 listen;
    std::vector<std::string>            allowed_methods;
    size_t                              client_max_body_size;
    bool                                autoindex;
    std::map<std::string, LocationBloc> locations;            
    ServerBloc();
    ~ServerBloc();
    void    print();
};/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpRequest.hpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 18:42:33 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 18:42:35 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <map>
#include <vector>

/*  TEMPLATE

first line      GET /index.html HTTP/1.1\r\n
header          Host: localhost:8080\r\n
header          User-Agent: Mozilla/5.0 (X11; Linux x86_64)\r\n
header          Accept: text/html\r\n
header          Connection: keep-alive\r\n
\r\n
body(optional)  {"username":"harold","password":"42"}

*/

class HttpRequest
{
    private:
        std::string                         _buffer;
        std::string                         _method;
        std::string                         _target;
        std::string                         _version;
        std::map<std::string, std::string>  _headers;
        std::string                         _body;
        int                                 _flag;

        //private methods
        bool                        is_valid_request()const;
        std::vector<std::string>    tokenize(const std::string buffer)const;

    public:
        //constructors
        HttpRequest();
        HttpRequest(const HttpRequest &copy);

        //destructors
        ~HttpRequest();

        //getters
        const std::string                           &getMethod()const;
        const std::string                           &getTarget()const;
        const std::string                           &getVersion()const;
        const std::map<std::string, std::string>    &getHeaders()const;
        const std::string                           &getBody()const;
        const int                                   &getFlag()const;


        //public methods
        void                        parse(const std::string &buffer);
        void                        print()const;
};
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpResponse.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 18:42:22 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 18:42:24 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include "HttpRequest.hpp"

/*  TEMPLATE

first line  HTTP/1.1 200 OK\r\n
header      Content-Type: text/html\r\n
header      Content-Length: 32\r\n
header      Connection: close\r\n
\r\n
body        <html><h1>Hello World</h1></html>

*/

class HttpResponse
{
    private:
        std::string                         _version;
        int                                 _statusCode;
        std::string                         _reason;
        std::map<std::string, std::string>  _headers;
        std::string                         _body;


    public:
        //constructors
        HttpResponse();
        HttpResponse(const HttpRequest &req);

        //destructors
        ~HttpResponse();

        //setters
        void    setVersion(const std::string &verion);
        void    setStatusCode(int code);
        void    setReason(const std::string &reason);
        void    setBody(const std::string &body);
        void    setHeaders(const std::string &version, const std::string &second);

        //methods
        std::string toStr();
        void        print();
};
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.hpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 17:48:30 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 17:48:31 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "HttpResponse.hpp"
#include "HttpRequest.hpp"
#include "Server.hpp"
#include "ServerMonitor.hpp"
#include "Config.hpp"
#include <stdexcept>
#include <limits>
#include <sys/types.h>
#include <dirent.h>

std::string                 strtrim(std::string &str);
std::string                 brackettrim(std::string &line);
std::string                 spacetrim(std::string &line);
bool                        is_closed(std::string str);
std::vector<std::string>    ft_split(const std::string &line, const std::string &separators);
int                         get_closing_bracket_index(std::string &str);
std::string                 commenttrim(std::string &str);
size_t                      safe_atosize_t(const std::string &str);
std::string                 trimmer(std::string &str);/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 17:48:36 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/22 00:00:00 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "Config.hpp"
#include "HttpRequest.hpp"
#include "HttpResponse.hpp"

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/wait.h> 
#include <unistd.h>
#include <fcntl.h>
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <stdexcept>
#include <sstream>
#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <sys/stat.h>
#include <cerrno>
#include <cstring>

class Server
{
    private:

        //based on config
        int                                 _listen;
        std::string                         _root;
        std::string                         _name;
        std::string                         _index;
        bool                                _autoindex;
        std::vector<std::string>            _allowed_methods;
        size_t                              _client_max_body_size;
        std::map<std::string, LocationBloc> _locations;

        //basic networking client<->server
        int					_server_fd;
		struct sockaddr_in	_address;
		fd_set				_read_fds;
		fd_set				_write_fds;
		fd_set				_master_fds;
		int					_max_fd;
		std::vector<int>	_client_fds;

    public:
        Server();
        //Server(const Server& other);
        Server(ServerBloc &bloc);
        //Server& operator=(const Server& other);
        ~Server();


        //networking methods
		int     get_server_fd(void) const;
		int     get_last_client_fd(void) const;
		bool    is_client_fd(int fd) const;
		void    accept_new_client(void);
		void    disconnect_client(int client_fd);

        void    init();
        void    print();
        void    shutdown();

        //response methods
        void            handle_client_request(int client_fd);
        HttpResponse    generate_response(HttpRequest &req);
        HttpResponse    generate_success_response(int code, const std::string &reason, const std::string &body);
        HttpResponse    generate_autoindex_response(const std::string &path, const std::string &target);
        HttpResponse    generate_get_response(HttpRequest &req);
        HttpResponse    generate_post_response(HttpRequest &req);
        HttpResponse    generate_delete_response(HttpRequest &req);
        HttpResponse    generate_error_response(int code, const std::string &reason, const std::string &details);
};

// ===== NOUVELLES DECLARATIONS CGI GLOBALES =====
// Fonctions principales CGI
HttpResponse ft_execute_cgi(const std::string& script_path, const HttpRequest& request, 
                           const std::string& server_name, int server_port);
bool ft_is_cgi_script(const std::string& file_path);

// Fonctions helper pour CGI
HttpResponse ft_build_cgi_response(const std::string& cgi_output);
HttpResponse ft_parse_cgi_headers(HttpResponse response, const std::string& headers_part, const std::string& body_part);
std::string ft_extract_query_string(const std::string& uri);
std::string ft_get_interpreter(const std::string& script_path);

// Fonctions pour l'exécution CGI
void ft_execute_cgi_child(const std::string& script_path, const HttpRequest& request,
                          const std::string& server_name, int server_port,
                          int pipe_in[2], int pipe_out[2]);
void ft_setup_cgi_environment(const HttpRequest& request, const std::string& server_name,
                              int server_port, const std::string& script_path);/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerMonitor.hpp                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hsorel <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/08 18:00:37 by hsorel            #+#    #+#             */
/*   Updated: 2025/09/08 18:00:38 by hsorel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include "Server.hpp"
#include <iostream>
#include <vector>
#include <algorithm>

class ServerMonitor
{
    private:
        std::string             _config;
        std::vector<Server>     _servers;
        fd_set                  _master_fds;
        int                     _max_fd;
        
        //private methods
        std::vector<std::string>    tokenize(const std::string &buffer);
        bool                        valid_brackets(const std::vector<std::string> &tokens);
        bool                        valid_semicolons(const std::vector<std::string> &tokens);
    public:

        //constructors
        ServerMonitor();
        ServerMonitor(std::string &config);

        //destructors
        ~ServerMonitor();

        //public methods
        void    addServer(Server server);
        void    parse();
        void    run();
        void    print();
        void    init_servers();

        //special function and it's special variable
        static void handle_sigint(int signum);
        static int              _flag;
};

